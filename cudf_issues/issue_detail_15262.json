{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/15262",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/15262/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/15262/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/15262/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/15262",
    "id": 2176891008,
    "node_id": "I_kwDOBWUGps6BwLiA",
    "number": 15262,
    "title": "[FEA] Add shared memory hash map for low-cardinality aggregations",
    "user": {
        "login": "GregoryKimball",
        "id": 12725111,
        "node_id": "MDQ6VXNlcjEyNzI1MTEx",
        "avatar_url": "https://avatars.githubusercontent.com/u/12725111?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/GregoryKimball",
        "html_url": "https://github.com/GregoryKimball",
        "followers_url": "https://api.github.com/users/GregoryKimball/followers",
        "following_url": "https://api.github.com/users/GregoryKimball/following{/other_user}",
        "gists_url": "https://api.github.com/users/GregoryKimball/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/GregoryKimball/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/GregoryKimball/subscriptions",
        "organizations_url": "https://api.github.com/users/GregoryKimball/orgs",
        "repos_url": "https://api.github.com/users/GregoryKimball/repos",
        "events_url": "https://api.github.com/users/GregoryKimball/events{/privacy}",
        "received_events_url": "https://api.github.com/users/GregoryKimball/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1139740666,
            "node_id": "MDU6TGFiZWwxMTM5NzQwNjY2",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/libcudf",
            "name": "libcudf",
            "color": "c5def5",
            "default": false,
            "description": "Affects libcudf (C++/CUDA) code."
        },
        {
            "id": 1322252617,
            "node_id": "MDU6TGFiZWwxMzIyMjUyNjE3",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Performance",
            "name": "Performance",
            "color": "C2E0C6",
            "default": false,
            "description": "Performance related issue"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
        "url": "https://api.github.com/repos/rapidsai/cudf/milestones/28",
        "html_url": "https://github.com/rapidsai/cudf/milestone/28",
        "labels_url": "https://api.github.com/repos/rapidsai/cudf/milestones/28/labels",
        "id": 9686188,
        "node_id": "MI_kwDOBWUGps4Ak8ys",
        "number": 28,
        "title": "Aggregations continuous improvement",
        "description": "",
        "creator": {
            "login": "GregoryKimball",
            "id": 12725111,
            "node_id": "MDQ6VXNlcjEyNzI1MTEx",
            "avatar_url": "https://avatars.githubusercontent.com/u/12725111?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/GregoryKimball",
            "html_url": "https://github.com/GregoryKimball",
            "followers_url": "https://api.github.com/users/GregoryKimball/followers",
            "following_url": "https://api.github.com/users/GregoryKimball/following{/other_user}",
            "gists_url": "https://api.github.com/users/GregoryKimball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/GregoryKimball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/GregoryKimball/subscriptions",
            "organizations_url": "https://api.github.com/users/GregoryKimball/orgs",
            "repos_url": "https://api.github.com/users/GregoryKimball/repos",
            "events_url": "https://api.github.com/users/GregoryKimball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/GregoryKimball/received_events",
            "type": "User",
            "site_admin": false
        },
        "open_issues": 8,
        "closed_issues": 1,
        "state": "open",
        "created_at": "2023-07-22T20:30:21Z",
        "updated_at": "2024-03-08T22:50:19Z",
        "due_on": null,
        "closed_at": null
    },
    "comments": 4,
    "created_at": "2024-03-08T22:50:19Z",
    "updated_at": "2024-05-29T22:42:18Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nlibcudf aggregations show lower throughput when data cardinality is less than ~1000 distinct values. This is due to serializing atomic operations over a small range of global memory. We received some projections that use hash maps that begin in shared memory and then spill to global if they exceed a certain size. The projections indicate 2-10x speedup for cardinalities below 100.\r\n\r\n![image](https://github.com/rapidsai/cudf/assets/12725111/f28d02c5-f107-4c4a-b44d-687094a0a7a8)\r\n(Aggregation throughput data was collected for groupby max over 20M rows of int64 key and int64 payload, based on benchmarks introduced in https://github.com/rapidsai/cudf/pull/15134 and using A100 hardware. Projections were provided as speedup versus cardinality data and were applied to the A100 measured throughput to yield projected throughput.)\r\n\r\n**Describe the solution you'd like**\r\nWe could provide an implementation that uses shared memory hash maps when cardinality is low. [Shared memory as storage](https://github.com/NVIDIA/cuCollections/blob/dev/examples/static_set/shared_memory_example.cu) is supported in [cuCollections](https://github.com/NVIDIA/cuCollections), so we could leverage this option to offer a higher throughput code path when cardinality is low.\r\n\r\nAs far as the API design, we could add an optional `cardinality` parameter to the `aggregate` API. When [hyperloglog](https://github.com/NVIDIA/cuCollections/pull/429) cardinality estimates are available in cuCollections, we may want to support cardinality estimates as well. Some open questions include:\r\n* What is the throughput difference between hyperloglog and count distinct? We expect the memory footprint of hyperloglog to be much lower, but I don't believe throughput has had controlled measurements.\r\n* If we accept cardinality estimates, what happens if the cardinality is underestimated and the shared memory hash map fails? \r\n* Does it make sense for column objects to track cardinality, or should the application layer track cardinality?\r\n\r\n\r\n**Describe alternatives you've considered**\r\nWe aren't sure how common low cardinality aggregation keys are in customer workloads. Are there cases where cardinality will be known ahead of time, or will it always need to be computed or estimated before triggering the aggregation? Could we instrument NDS to log cardinality and row count before each aggregation node?\r\n\r\n**Additional context**\r\nWe could also consider using shared memory hash maps for low-cardinality distinct-key joins. This optimization is mentioned in https://github.com/rapidsai/cudf/issues/14948.\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/15262/reactions",
        "total_count": 1,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 1,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/15262/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}