{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/13544",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/13544/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/13544/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/13544/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/13544",
    "id": 1750257581,
    "node_id": "I_kwDOBWUGps5oUs-t",
    "number": 13544,
    "title": "[ENH]: Reimagining cudf user-input boundaries",
    "user": {
        "login": "wence-",
        "id": 1126981,
        "node_id": "MDQ6VXNlcjExMjY5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/wence-",
        "html_url": "https://github.com/wence-",
        "followers_url": "https://api.github.com/users/wence-/followers",
        "following_url": "https://api.github.com/users/wence-/following{/other_user}",
        "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
        "organizations_url": "https://api.github.com/users/wence-/orgs",
        "repos_url": "https://api.github.com/users/wence-/repos",
        "events_url": "https://api.github.com/users/wence-/events{/privacy}",
        "received_events_url": "https://api.github.com/users/wence-/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 1322252617,
            "node_id": "MDU6TGFiZWwxMzIyMjUyNjE3",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Performance",
            "name": "Performance",
            "color": "C2E0C6",
            "default": false,
            "description": "Performance related issue"
        },
        {
            "id": 2546521024,
            "node_id": "MDU6TGFiZWwyNTQ2NTIxMDI0",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/improvement",
            "name": "improvement",
            "color": "bfd4f2",
            "default": false,
            "description": "Improvement / enhancement to an existing function"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-06-09T17:26:44Z",
    "updated_at": "2024-02-23T17:59:06Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "tl;dr: If you squint, everything is really a compiler problem in disguise.\r\n\r\n\r\n## Overview\r\n\r\nThe pandas API is very broad and has numerous places where \"best effort\" attempts are made to DWIM (do what I mean). One example is during dataframe indexing, where a significant effort is made to \"desugar\" the user input into a canonical form.\r\n\r\nFor example, turning `df.loc[[1, 2, 3]]` into `df.loc[[1, 2, 3], :]` (that is, a single entry on a dataframe is equivalent to taking rows and *all* the columns).\r\n\r\nThis pattern is pervasive, to take another different example, `read_parquet` accepts as the \"file\" object:\r\n\r\n1.  a string (indicating a file to open)\r\n2.  a Path object\r\n3.  raw bytes\r\n4.  Anything with a `read` method\r\n5.  A list (maybe sequence?) of the above\r\n\r\n\r\n## The status quo\r\n\r\nTo handle this kind of multi-modal unstructured input, the user-visible API of cudf carries out inspection and validation of the inputs before dispatching to appropriate lower-level routines. By the time we reach libcudf, all decisions must have been made.\r\n\r\nThis works, but has a number of problems:\r\n\r\n1.  It is not always clear *whose* job it is to do the validation. Is any \"pseudo-public\" method required to validate correctness of its inputs? Or is it always the job of the definitively public API to validate all inputs before handing off. One sees this in private `Frame` methods like `_gather` which have an explicit `check_bounds` flag (which often is not set when it could be, because the only *safe* default is `True`).\r\n2.  Validation just checks for valid inputs and then returns types unchanged (so defensive programming requires consumers of the input to assume worst-case scenarios and check things again).\r\n3.  Consequently, validation and inspection often occur (on any given input): \r\n    i. More than once \r\n    ii. Inconsistently (generally this is not deliberate, it's just hard to keep track).\r\n\r\n\r\n## Proposal\r\n\r\nI propose that we take a leaf out of the type-driven design crowd's book and treat the user-facing input validation as a *parsing* rather than *validating* problem. What does this mean? Rather than just checking input in user-facing API functions and dispatching to internal functions that *receive the same type* we should tighten the types as we go, \"parsing\" the unstructured user input into more structured data as we transit through the call stack.\r\n\r\nThis has, I think, a number of advantages:\r\n\r\n1.  It clarifies *where* in the implementation validation in dispatch takes place (any time a type changes), separating the business logic of making sense of the input from the concrete implementation for the different paths.\r\n2.  It makes cross-calling between internal APIs that *don't* do validation safe. For example, rather than `_gather` having the signature `a -> Column -> Maybe a` for some dataframe type `a` and always having to check that the provided column is inbounds as a gather map, we would tighten the type to `a -> InBoundsFor a Column -> a`. Now the gather map comes with a \"proof\" that it is inbounds for the dataframe we are gathering, and we therefore do not have to do bounds checking[^1]. Now, we can't statically enforce this (in the sense that in the implementation, someone will be able to conjure the \"proof\" out of thin air if they really want to), but type checking will at least indicate when we don't promise an in-bounds column.\r\n3.  By separating the business logic from the backend dispatch we keep the good work we've done in producing a pandas-like API and make it *easier* to (on the long term) slot in other backends (for example a distributed, multi-node, backend underneath the cudf front-facing API).\r\n\r\n\r\n[^1]: In a statically typed language with rank-N types you can actually make these proofs [part of the type system](https://kataskeue.com/gdp.pdf), though we can't here in Python.\r\n\r\n## Further reading\r\n\r\n- A nice overview of this idea with more examples: https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/\r\n- Similar ideas as the \"typestate\" pattern: https://cliffle.com/blog/rust-typestate/\r\n- \"Make illegal states unrepresentable\": https://buttondown.email/hillelwayne/archive/making-illegal-states-unrepresentable/",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/13544/reactions",
        "total_count": 2,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 2,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/13544/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}