{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/15459",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/15459/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/15459/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/15459/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/15459",
    "id": 2223841189,
    "node_id": "I_kwDOBWUGps6EjR-l",
    "number": 15459,
    "title": "[BUG] Unpickling objects with `pd.read_pickle()` doesn't work with cudf.pandas enabled",
    "user": {
        "login": "shwina",
        "id": 3190405,
        "node_id": "MDQ6VXNlcjMxOTA0MDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3190405?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/shwina",
        "html_url": "https://github.com/shwina",
        "followers_url": "https://api.github.com/users/shwina/followers",
        "following_url": "https://api.github.com/users/shwina/following{/other_user}",
        "gists_url": "https://api.github.com/users/shwina/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/shwina/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/shwina/subscriptions",
        "organizations_url": "https://api.github.com/users/shwina/orgs",
        "repos_url": "https://api.github.com/users/shwina/repos",
        "events_url": "https://api.github.com/users/shwina/events{/privacy}",
        "received_events_url": "https://api.github.com/users/shwina/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626559,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NTk=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/bug",
            "name": "bug",
            "color": "d73a4a",
            "default": true,
            "description": "Something isn't working"
        },
        {
            "id": 6815620706,
            "node_id": "LA_kwDOBWUGps8AAAABlj4eYg",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/cudf.pandas",
            "name": "cudf.pandas",
            "color": "984DFB",
            "default": false,
            "description": "Issues specific to cudf.pandas"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
        "url": "https://api.github.com/repos/rapidsai/cudf/milestones/35",
        "html_url": "https://github.com/rapidsai/cudf/milestone/35",
        "labels_url": "https://api.github.com/repos/rapidsai/cudf/milestones/35/labels",
        "id": 10812591,
        "node_id": "MI_kwDOBWUGps4ApPyv",
        "number": 35,
        "title": "Proxying - cudf.pandas",
        "description": "",
        "creator": {
            "login": "galipremsagar",
            "id": 11664259,
            "node_id": "MDQ6VXNlcjExNjY0MjU5",
            "avatar_url": "https://avatars.githubusercontent.com/u/11664259?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/galipremsagar",
            "html_url": "https://github.com/galipremsagar",
            "followers_url": "https://api.github.com/users/galipremsagar/followers",
            "following_url": "https://api.github.com/users/galipremsagar/following{/other_user}",
            "gists_url": "https://api.github.com/users/galipremsagar/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/galipremsagar/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/galipremsagar/subscriptions",
            "organizations_url": "https://api.github.com/users/galipremsagar/orgs",
            "repos_url": "https://api.github.com/users/galipremsagar/repos",
            "events_url": "https://api.github.com/users/galipremsagar/events{/privacy}",
            "received_events_url": "https://api.github.com/users/galipremsagar/received_events",
            "type": "User",
            "site_admin": false
        },
        "open_issues": 16,
        "closed_issues": 13,
        "state": "open",
        "created_at": "2024-04-12T16:41:23Z",
        "updated_at": "2024-06-03T21:47:19Z",
        "due_on": null,
        "closed_at": null
    },
    "comments": 0,
    "created_at": "2024-04-03T20:24:39Z",
    "updated_at": "2024-04-15T14:34:02Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Describe the bug**\r\nWhen `cudf.pandas` is enabled, we can pickle and unpickle objects using `pickle.dump/load` or `pickle.dumps/loads`. But if we choose to unpickle with `pd.read_pickle`, things go awry. Here's a minimal reproducer:\r\n\r\n```python\r\nimport pandas as pd\r\nfrom io import BytesIO\r\nimport pickle\r\n\r\npdf = pd.DataFrame({'a': [1.0, 2.0, None, 3.0]})\r\n\r\nwith open(\"pickled_pdf.pkl\", \"wb\") as f:\r\n    pickle.dump(pdf, f)\r\n\r\nwith open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n    df = pd.read_pickle(f)\r\n\r\nprint(df)\r\n```\r\n\r\n<details>\r\n\r\n```\r\nIn [1]: %load_ext cudf.pandas\r\n\r\nIn [2]: import pandas as pd\r\n\r\nIn [3]: from io import BytesIO\r\n   ...: import pickle\r\n   ...: \r\n   ...: pdf = pd.DataFrame({'a': [1.0, 2.0, None, 3.0]})\r\n   ...: \r\n   ...: with open(\"pickled_pdf.pkl\", \"wb\") as f:\r\n   ...:     pickle.dump(pdf, f)\r\n   ...: \r\n   ...: with open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n   ...:     df = pd.read_pickle(f)\r\n   ...: \r\n   ...: print(df)\r\n---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:888, in _fast_slow_function_call(func, *args, **kwargs)\r\n    883 with nvtx.annotate(\r\n    884     \"EXECUTE_FAST\",\r\n    885     color=_CUDF_PANDAS_NVTX_COLORS[\"EXECUTE_FAST\"],\r\n    886     domain=\"cudf_pandas\",\r\n    887 ):\r\n--> 888     fast_args, fast_kwargs = _fast_arg(args), _fast_arg(kwargs)\r\n    889     result = func(*fast_args, **fast_kwargs)\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:1007, in _fast_arg(arg)\r\n   1006 seen: Set[int] = set()\r\n-> 1007 return _transform_arg(arg, \"_fsproxy_fast\", seen)\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:934, in _transform_arg(arg, attribute_name, seen)\r\n    932 if type(arg) is tuple:\r\n    933     # Must come first to avoid infinite recursion\r\n--> 934     return tuple(_transform_arg(a, attribute_name, seen) for a in arg)\r\n    935 elif hasattr(arg, \"__getnewargs_ex__\"):\r\n    936     # Partial implementation of to reconstruct with\r\n    937     # transformed pieces\r\n    938     # This handles scipy._lib._bunch._make_tuple_bunch\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:934, in <genexpr>(.0)\r\n    932 if type(arg) is tuple:\r\n    933     # Must come first to avoid infinite recursion\r\n--> 934     return tuple(_transform_arg(a, attribute_name, seen) for a in arg)\r\n    935 elif hasattr(arg, \"__getnewargs_ex__\"):\r\n    936     # Partial implementation of to reconstruct with\r\n    937     # transformed pieces\r\n    938     # This handles scipy._lib._bunch._make_tuple_bunch\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:917, in _transform_arg(arg, attribute_name, seen)\r\n    916 if isinstance(arg, (_FastSlowProxy, _FastSlowProxyMeta, _FunctionProxy)):\r\n--> 917     typ = getattr(arg, attribute_name)\r\n    918     if typ is _Unusable:\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:553, in _FastSlowProxy.__getattr__(self, name)\r\n    550 if name.startswith(\"_fsproxy\"):\r\n    551     # an AttributeError was raised when trying to evaluate\r\n    552     # an internal attribute, we just need to propagate this\r\n--> 553     _raise_attribute_error(self.__class__.__name__, name)\r\n    554 if name in {\r\n    555     \"_ipython_canary_method_should_not_exist_\",\r\n    556     \"_ipython_display_\",\r\n   (...)\r\n    568     # This is somewhat delicate to the order in which IPython\r\n    569     # implements special display fallbacks.\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:392, in _raise_attribute_error(obj, name)\r\n    387 \"\"\"\r\n    388 Raise an AttributeError with a message that is consistent with\r\n    389 the error raised by Python for a non-existent attribute on a\r\n    390 proxy object.\r\n    391 \"\"\"\r\n--> 392 raise AttributeError(f\"'{obj}' object has no attribute '{name}'\")\r\n\r\nAttributeError: 'function' object has no attribute '_fsproxy_fast'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nAttributeError                            Traceback (most recent call last)\r\n<ipython-input-3-deda8b8b446c> in ?()\r\n      8 \r\n      9 with open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n     10     df = pd.read_pickle(f)\r\n     11 \r\n---> 12 print(df)\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(self, *args, **kwargs)\r\n    836     def __call__(self, *args, **kwargs) -> Any:\r\n--> 837         result, _ = _fast_slow_function_call(\r\n    838             # We cannot directly call self here because we need it to be\r\n    839             # converted into either the fast or slow object (by\r\n    840             # _fast_slow_function_call) to avoid infinite recursion.\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(func, *args, **kwargs)\r\n    898             domain=\"cudf_pandas\",\r\n    899         ):\r\n    900             slow_args, slow_kwargs = _slow_arg(args), _slow_arg(kwargs)\r\n    901             with disable_module_accelerator():\r\n--> 902                 result = func(*slow_args, **slow_kwargs)\r\n    903     return _maybe_wrap_result(result, func, *args, **kwargs), fast\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(fn, args, kwargs)\r\n     29 def call_operator(fn, args, kwargs):\r\n---> 30     return fn(*args, **kwargs)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/frame.py in ?(self)\r\n   1199             self.info(buf=buf)\r\n   1200             return buf.getvalue()\r\n   1201 \r\n   1202         repr_params = fmt.get_dataframe_repr_params()\r\n-> 1203         return self.to_string(**repr_params)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/util/_decorators.py in ?(*args, **kwargs)\r\n    329                     msg.format(arguments=_format_argument_list(allow_args)),\r\n    330                     FutureWarning,\r\n    331                     stacklevel=find_stack_level(),\r\n    332                 )\r\n--> 333             return func(*args, **kwargs)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/frame.py in ?(self, buf, columns, col_space, header, index, na_rep, formatters, float_format, sparsify, index_names, justify, max_rows, max_cols, show_dimensions, decimal, line_width, min_rows, max_colwidth, encoding)\r\n   1361         \"\"\"\r\n   1362         from pandas import option_context\r\n   1363 \r\n   1364         with option_context(\"display.max_colwidth\", max_colwidth):\r\n-> 1365             formatter = fmt.DataFrameFormatter(\r\n   1366                 self,\r\n   1367                 columns=columns,\r\n   1368                 col_space=col_space,\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/io/formats/format.py in ?(self, frame, columns, col_space, header, index, na_rep, formatters, justify, float_format, sparsify, index_names, max_rows, min_rows, max_cols, show_dimensions, decimal, bold_rows, escape)\r\n    443         bold_rows: bool = False,\r\n    444         escape: bool = True,\r\n    445     ) -> None:\r\n    446         self.frame = frame\r\n--> 447         self.columns = self._initialize_columns(columns)\r\n    448         self.col_space = self._initialize_colspace(col_space)\r\n    449         self.header = header\r\n    450         self.index = index\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/io/formats/format.py in ?(self, columns)\r\n    552             cols = ensure_index(columns)\r\n    553             self.frame = self.frame[cols]\r\n    554             return cols\r\n    555         else:\r\n--> 556             return self.frame.columns\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, name)\r\n   6292             and name not in self._accessors\r\n   6293             and self._info_axis._can_hold_identifiers_and_holds_name(name)\r\n   6294         ):\r\n   6295             return self[name]\r\n-> 6296         return object.__getattribute__(self, name)\r\n\r\nproperties.pyx in ?()\r\n---> 65 'Could not get source, probably due dynamically evaluated source code.'\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, name)\r\n   6292             and name not in self._accessors\r\n   6293             and self._info_axis._can_hold_identifiers_and_holds_name(name)\r\n   6294         ):\r\n   6295             return self[name]\r\n-> 6296         return object.__getattribute__(self, name)\r\n\r\nAttributeError: 'DataFrame' object has no attribute '_mgr'\r\n```\r\n</details>\r\n \r\nWe can (and do) control what happens when objects are pickled and unpickled via the pickle protocol (`pickle.dump` and `pickle.load`) [here](https://github.com/rapidsai/cudf/blob/5192b608eeed4bda9317c657253c3a5630aa4c5d/python/cudf/cudf/pandas/fast_slow_proxy.py#L722-L741). \r\n\r\nAnd pandas' `read_pickle` does call the \"regular\" [`pickle.load` function](https://github.com/pandas-dev/pandas/blob/05ab1af783f6590b8a2d9fbea6d39793e88dfb04/pandas/io/pickle.py#L203). \r\n\r\nSo what's going on?\r\n\r\nWhen we call `pd.read_pickle` in `cudf.pandas` mode, that will first call `cudf.read_pickle` (doesn't exist) and then fall back to the real `pandas.read_pickle`. Importantly, during fallback, we [disable ourselves](https://github.com/rapidsai/cudf/blob/5192b608eeed4bda9317c657253c3a5630aa4c5d/python/cudf/cudf/pandas/fast_slow_proxy.py#L901). Which means that our special pickle protocol handling doesn't kick in and that messes everything up. \r\n\r\n### Solutions\r\n\r\nThe only solution I could think of is we vendor `pandas.read_pickle`, so we can keep ourselves enabled when it is called.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/15459/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/15459/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}