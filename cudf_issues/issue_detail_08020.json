{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/8020",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/8020/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/8020/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/8020/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/8020",
    "id": 864115307,
    "node_id": "MDU6SXNzdWU4NjQxMTUzMDc=",
    "number": 8020,
    "title": "[FEA] aggregation each list in a column to a single value using a user supplied function",
    "user": {
        "login": "revans2",
        "id": 3441321,
        "node_id": "MDQ6VXNlcjM0NDEzMjE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/revans2",
        "html_url": "https://github.com/revans2",
        "followers_url": "https://api.github.com/users/revans2/followers",
        "following_url": "https://api.github.com/users/revans2/following{/other_user}",
        "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
        "organizations_url": "https://api.github.com/users/revans2/orgs",
        "repos_url": "https://api.github.com/users/revans2/repos",
        "events_url": "https://api.github.com/users/revans2/events{/privacy}",
        "received_events_url": "https://api.github.com/users/revans2/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1013987352,
            "node_id": "MDU6TGFiZWwxMDEzOTg3MzUy",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/0%20-%20Backlog",
            "name": "0 - Backlog",
            "color": "d4c5f9",
            "default": false,
            "description": "In queue waiting for assignment"
        },
        {
            "id": 1139740666,
            "node_id": "MDU6TGFiZWwxMTM5NzQwNjY2",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/libcudf",
            "name": "libcudf",
            "color": "c5def5",
            "default": false,
            "description": "Affects libcudf (C++/CUDA) code."
        },
        {
            "id": 1405146975,
            "node_id": "MDU6TGFiZWwxNDA1MTQ2OTc1",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Spark",
            "name": "Spark",
            "color": "7400ff",
            "default": false,
            "description": "Functionality that helps Spark RAPIDS"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-21T17:31:59Z",
    "updated_at": "2023-06-22T15:02:43Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nSpark supports the aggregate function in SQL (Not really standard but we have customers who use it)\r\n\r\nhttps://spark.apache.org/docs/latest/api/sql/index.html#aggregate\r\n\r\nIt takes 4 arguments.\r\n  * **argument** an array/list column to do the aggregation on\r\n  * **initial** an initial value for accumulation\r\n  * **merge** a higher order function that takes two arguments an accumulation value and the current value in the list\r\n  * **finish** an optional higher order function that takes the output of merge and transforms it into a final value\r\n \r\nA higher order function is a function that is written in SQL like `(a, b) -> a + b` to add two things together.\r\n\r\nEven though **finish** is a higher order function we don't have to treat it that way so we can ignore it for now.\r\n\r\n**merge** however is something new that CUDF has not really supported before. It allows the user to specify how they want an aggregation to happen instead of having a declarative aggregation like most SQL does.  So for example if I wanted to do the equivalent of SUM it would look something like\r\n\r\n```\r\nSELECT aggregate(list_of_int_column, 0, (acc, x) -> acc + x) as sum_of_ints_in_list\r\n```\r\n\r\nFor each list in the column it would do essentially the equivalent of\r\n\r\n```\r\nMERGE_OUTPUT_TYPE acc = initial_value;\r\nfor (ELEMENT_TYPE & elem : list_data) {\r\n  acc = merge(acc, elem);\r\n}\r\n```\r\n\r\nThe problem we are running into is that our customers have rather complicated operations, where the higher order function can reach out to other columns in the same row.\r\n\r\n```\r\n(acc, x) -> (\r\n  CASE WHEN other_column - x.struct_sub_column >= acc\r\n                         AND other_column - x.struct_sub_column < 100\r\n                         AND x.struct_string_column = 'FOO'\r\n                         AND yet_another_column <> x.third_struct_sub_column\r\n             THEN other_column - x.struct_sub_column\r\n             ELSE acc\r\n  END))\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nI would love something where we could build up an AST tree that represents the higher order function and have cudf provide a list_aggregation function that would do what we need/want. But we know that there are potentially issues with the AST in terms or performance when there are too many operators so this is all open to discussion.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nWe have thought about trying to do pattern matching to decompose the higher order function into something more manageable for CUDF to support.\r\n\r\ni.e.\r\n\r\n```\r\n(acc, x) -> acc + x\r\n```\r\ncould be translated into an SUM aggregation across the values in the list, or \r\n\r\n```\r\n(acc, x) -> CASE WHEN x > acc THEN x ELSE acc END\r\n```\r\n\r\ncould be translated into a MAX aggregation across the values in the list.\r\n\r\nWe could even use pattern matching for things like \r\n\r\n```\r\n(acc, x) -> acc + x.first - x.second\r\n```\r\n\r\nTo translate it into first doing a `x.first - x.second` for all of the struct values within the list, and then doing a SUM aggregation on that resulting list.  But things get much more difficult when we try to support pulling in other columns, and struct columns, etc.\r\n\r\n```\r\n(acc, x) -> acc + x.first + foo\r\n```\r\n\r\nIn this case we would have to do essentially an `explode` on `foo` and the list column so we could execute `x.first + foo` and then finally do the SUM aggregation. This is a bit problematic because of potential memory issues that explode can cause.\r\n\r\nSo if the AST is not a workable solution we would like to request a generic list aggregation operation instead.\r\n\r\n```\r\ncudf::column list_aggregate(cudf::lists_column_view list, std::unique_ptr<aggregation> & aggregation);\r\n```\r\n\r\nWith at a minimum supporting MAX, SUM, and MIN aggregations initially.\r\n\r\nIt would probably be ideal to expand it out to multiple aggregations at once like with `groupby`, but it is not a requirement.\r\n\r\nI also need to add that null handling would have to be a bit different than other aggregations. If the list itself is a null, then the output should be a null, but if a value in the list is a null, then the output should also be a null.\r\n\r\n```\r\nscala> spark.sql(\"SELECT aggregate(array(1, 2, 3), 0, (acc, x) -> acc + x) as A\").show\r\n+---+\r\n|  A|\r\n+---+\r\n|  6|\r\n+---+\r\n\r\n\r\nscala> spark.sql(\"SELECT aggregate(array(1, 2, 3, null), 0, (acc, x) -> acc + x) as A\").show\r\n+----+\r\n|   A|\r\n+----+\r\n|null|\r\n+----+\r\n```\r\n\r\nIdeally we would also love to have some kind of explode that would not make a copy of the array we are exploding on, but instead just do the explode on the columns that need it.\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/8020/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/8020/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}