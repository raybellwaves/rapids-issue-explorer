{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/10920",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/10920/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/10920/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/10920/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/10920",
    "id": 1243867072,
    "node_id": "I_kwDOBWUGps5KI-fA",
    "number": 10920,
    "title": "[FEA] Introduce distributed computing stages, then combine groupby and reduction aggregations",
    "user": {
        "login": "ttnghia",
        "id": 7416935,
        "node_id": "MDQ6VXNlcjc0MTY5MzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7416935?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ttnghia",
        "html_url": "https://github.com/ttnghia",
        "followers_url": "https://api.github.com/users/ttnghia/followers",
        "following_url": "https://api.github.com/users/ttnghia/following{/other_user}",
        "gists_url": "https://api.github.com/users/ttnghia/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/ttnghia/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ttnghia/subscriptions",
        "organizations_url": "https://api.github.com/users/ttnghia/orgs",
        "repos_url": "https://api.github.com/users/ttnghia/repos",
        "events_url": "https://api.github.com/users/ttnghia/events{/privacy}",
        "received_events_url": "https://api.github.com/users/ttnghia/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 1013987921,
            "node_id": "MDU6TGFiZWwxMDEzOTg3OTIx",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/proposal",
            "name": "proposal",
            "color": "2a2c89",
            "default": false,
            "description": "Change current process or code"
        },
        {
            "id": 1139740666,
            "node_id": "MDU6TGFiZWwxMTM5NzQwNjY2",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/libcudf",
            "name": "libcudf",
            "color": "c5def5",
            "default": false,
            "description": "Affects libcudf (C++/CUDA) code."
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-05-21T04:38:00Z",
    "updated_at": "2024-02-23T18:42:35Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Background.**\r\nDistributed computing aggregations are typically performed in 3 stages:\r\n1. Update: Computes intermediate results at each node.\r\n2. Merge: Merge multiple intermediate results of the update stages from different nodes.\r\n3. Evaluate: Compute the final result of the aggregation. \r\n\r\nOnly the result of the last stage is what the users want to get. The intermediate results are typically used internally by the library and do not need to be exposed to the users.\r\n\r\nHowever, currently in libcudf, for several aggregations, we have implemented separate public aggregations for each of these stages. Let's look at several aggregations: \r\n * `M2` and `MERGE_M2`\r\n * `TDIGEST` and `MERGE_TDIGEST`\r\n * `COLLECT_LIST` and `MERGE_LISTS`\r\n * `COLLECT_SET` and `MERGE_SETS`\r\n\r\nThese aggregations generate only (intermediate) results that must be used together to generate the final result. Thus, it makes more sense to unify them together so the intermediate results of one aggregation class can be processed by the same class in the next stage.\r\n\r\n**Describe the solution**\r\nWe should only provide just one public aggregation for each kind of operation that has the right and meaningful name. For example, just `STANDARD_DEVIATION` aggregation that can perform all the `Update`, `Merge`, and `Evaluate` stages. Upon constructing an instance of the aggregation, we pass in a parameter specifying which stage the aggregation should do its job. Such parameter can be something like this:\r\n```\r\nenum class distributed_computing_stage {\r\nUPDATE,\r\nMERGE,\r\nEVALUATE,\r\nALL_IN_ONE // Generate the final result directly in just one pass (no distributed computing supported)\r\n};\r\n```\r\n\r\nSo we will construct the aggregation like this:\r\n```\r\ntemplate <typename Base = aggregation>\r\nstd::unique_ptr<Base> make_std_aggregation(distributed_computing_stage stage = ALL_IN_ONE, size_type ddof = 1);\r\n```\r\n\r\n**Benefits**\r\nThe architecture I propose here can make the aggregations sound more meaningful. For example, we have a `STANDARD_DEVIATION` aggregation that will produce its own intermediate results, which will be merged by the same `STANDARD_DEVIATION` aggregation class, and the final result can be computed by the same `STANDARD_DEVIATION` aggregation class. It makes much more sense than computing the intermediate results by calling `M2` aggregation, then calling `MERGE_M2` aggregation, then evaluating the final result.\r\n\r\nIt also can simplify the implementation of aggregations a lot. It allows to reduce the number of classes, reducing the number of factory methods (`make_xxx_aggregation`), reducing the number of related methods (like `std::vector<std::unique_ptr<aggregation>> simple_aggregations_collector::visit` and `void aggregation_finalizer::visit`) etc.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/10920/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/10920/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}