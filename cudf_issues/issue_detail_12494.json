{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/12494",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/12494/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/12494/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/12494/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/12494",
    "id": 1523382686,
    "node_id": "I_kwDOBWUGps5azPme",
    "number": 12494,
    "title": "[FEA] Cache the outputs of type utilities",
    "user": {
        "login": "vyasr",
        "id": 1538165,
        "node_id": "MDQ6VXNlcjE1MzgxNjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1538165?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vyasr",
        "html_url": "https://github.com/vyasr",
        "followers_url": "https://api.github.com/users/vyasr/followers",
        "following_url": "https://api.github.com/users/vyasr/following{/other_user}",
        "gists_url": "https://api.github.com/users/vyasr/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/vyasr/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/vyasr/subscriptions",
        "organizations_url": "https://api.github.com/users/vyasr/orgs",
        "repos_url": "https://api.github.com/users/vyasr/repos",
        "events_url": "https://api.github.com/users/vyasr/events{/privacy}",
        "received_events_url": "https://api.github.com/users/vyasr/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1139741213,
            "node_id": "MDU6TGFiZWwxMTM5NzQxMjEz",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Python",
            "name": "Python",
            "color": "1d76db",
            "default": false,
            "description": "Affects Python cuDF API."
        },
        {
            "id": 1322252617,
            "node_id": "MDU6TGFiZWwxMzIyMjUyNjE3",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Performance",
            "name": "Performance",
            "color": "C2E0C6",
            "default": false,
            "description": "Performance related issue"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-01-07T01:24:16Z",
    "updated_at": "2024-05-17T16:00:17Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nThe use of type utilities in `cudf.api.types` is widespread throughout cudf. Some of this usage is problematic and should be removed -- in many places, we would be better off leveraging the columnar type hierarchy in cudf to implement additional functionality as methods of the appropriate subclass of `ColumnBase`. However, there are also many places where the usage of these utility functions is unavoidable, especially in functions like `astype` or `build_column` that need to dispatch based on an input dtype. The problem is that these methods are _slow_, especially when compared to the equivalent `isinstance` checks for primitive types. For instance, `pd.api.types.is_numeric_dtype` takes ~1.2 us as compared to ~50-80 ns for `isinstance(val, int)`. Although these absolute numbers are small, that factor of 10-20 is significant because many common cudf functions can call these functions dozens of times (consider e.g. merges or groupbys). We would benefit from reducing this overhead as much as possible.\r\n\r\n**Describe the solution you'd like**\r\nThese functions should all wrap their logic in a cache to bypass the calls on commonly reused types. Here is a simple example:\r\n```\r\nIn [48]: from functools import lru_cache\r\n\r\nIn [49]: import pandas as pd\r\n\r\nIn [50]: @lru_cache\r\n    ...: def is_numeric_type_cached(dtype):\r\n    ...:     return pd.api.types.is_numeric_dtype(dtype)\r\n    ...: \r\n\r\nIn [51]: def is_numeric_type(arr_or_dtype):\r\n    ...:     if dt := getattr(arr_or_dtype, \"dtype\", None):\r\n    ...:         arr_or_dtype = dt\r\n    ...:     return is_numeric_type_cached(arr_or_dtype)\r\n    ...: \r\n\r\nIn [52]: s = pd.Series([1])\r\n\r\nIn [53]: %timeit pd.api.types.is_numeric_dtype(s)\r\n1.88 \u00b5s \u00b1 7.23 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n\r\nIn [54]: %timeit pd.api.types.is_numeric_dtype(s.dtype)\r\n1.14 \u00b5s \u00b1 7.26 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n\r\nIn [55]: %timeit is_numeric_type(s.dtype)\r\n471 ns \u00b1 1.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n\r\nIn [56]: %timeit is_numeric_type(s)\r\n466 ns \u00b1 1.98 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n```\r\nNote the importance of the wrapper function to support calling these utilities with any object that exposes a `dtype` attribute such as a Series or a numpy/cupy array (we obviously don't want to cache those objects directly). We may need additional such logic in certain specific cases (perhaps categoricals or nested types). Nevertheless, as shown above using a cache could reduce the cost of the APIs of a factor of ~3 on average.\r\n\r\n**Describe alternatives you've considered**\r\nA more natural alternative that I considered was leveraging `functools.singledispatch`. Unfortunately, we are largely foiled in this attempt by the fact that the different possible \"dtype-like\" objects do not fit into simple class delinations, which is how dispatch is performed. In the worst case, all dtypes are specified with strings like \"int\" or \"float\", all of which end up dispatched to the same type.\r\n\r\n**Additional context**\r\nIn theory this could be abused to result in some ridiculous caching, e.g. if a user calls these methods with some arbitrary object that isn't a valid dtype-like object and ends up being stored in the cache. To prevent the worst excesses we should limit the cache size.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/12494/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/12494/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}