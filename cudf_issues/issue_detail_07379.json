{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/7379",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/7379/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/7379/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/7379/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/7379",
    "id": 807245434,
    "node_id": "MDU6SXNzdWU4MDcyNDU0MzQ=",
    "number": 7379,
    "title": "[FEA] have cudf::merge or similar API be stable, with the order of the tables passed in",
    "user": {
        "login": "revans2",
        "id": 3441321,
        "node_id": "MDQ6VXNlcjM0NDEzMjE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/revans2",
        "html_url": "https://github.com/revans2",
        "followers_url": "https://api.github.com/users/revans2/followers",
        "following_url": "https://api.github.com/users/revans2/following{/other_user}",
        "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
        "organizations_url": "https://api.github.com/users/revans2/orgs",
        "repos_url": "https://api.github.com/users/revans2/repos",
        "events_url": "https://api.github.com/users/revans2/events{/privacy}",
        "received_events_url": "https://api.github.com/users/revans2/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1013987352,
            "node_id": "MDU6TGFiZWwxMDEzOTg3MzUy",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/0%20-%20Backlog",
            "name": "0 - Backlog",
            "color": "d4c5f9",
            "default": false,
            "description": "In queue waiting for assignment"
        },
        {
            "id": 1139740666,
            "node_id": "MDU6TGFiZWwxMTM5NzQwNjY2",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/libcudf",
            "name": "libcudf",
            "color": "c5def5",
            "default": false,
            "description": "Affects libcudf (C++/CUDA) code."
        },
        {
            "id": 1405146975,
            "node_id": "MDU6TGFiZWwxNDA1MTQ2OTc1",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Spark",
            "name": "Spark",
            "color": "7400ff",
            "default": false,
            "description": "Functionality that helps Spark RAPIDS"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 10,
    "created_at": "2021-02-12T13:41:57Z",
    "updated_at": "2021-04-19T14:06:15Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nSpark's sort is a stable sort.  Most of the time that does not mater much, but there are a few cases where it does make a difference in the output (some window functions in a single process).\r\n\r\n`cudf::merge` currently provides no way to ensure that if batch 1 came before batch 2 in read order that the output would be preserved.\r\n\r\n**Describe the solution you'd like**\r\nIt would be great in the case of ties in cudf::merge if the order of the rows could match the order of the tables passed in. If this is going to cause a performance difference with the existing merge then a separate API is fine too.\r\n\r\n**Describe alternatives you've considered**\r\nAdd in a separate row of longs with all of the data that is a sequence to get a total ordering of the data read in so I can then use it as the final key in the sort, but that adds a lot of extra memory for something that is a really rare use case.\r\n\r\n**Additional context**\r\nThis is not super critical, as I said it is for a few corner cases. But from looking at the code it looks like it is simple enough that I could do it. The underlying `trust::merge` says that it is stable for what we want in the docs. That just leaves the order in which the tables are merged. It looks like right now there is a priority queue used to try and reduce the amount of data transferred and merges done by merging the two smallest tables at a time. I think if we instead merged them in waves, we could still reduce the amount of intermediate data transferred and maintain stable ordering.  Not as clean as the existing code but the following pseudo code would probably do what we want.\r\n\r\n```\r\nqueue input(all the input tables)\r\nqueue output()\r\nwhile (input.size > 1) {\r\n  while (input.size > 1) {\r\n    left = input.pop\r\n    right = input.pop\r\n    output.add(merge(left, right))\r\n  }\r\n  if (input.size == 1) {\r\n    output.add(input.pop)\r\n  }\r\n  input = output\r\n  output.reset()\r\n}\r\nreturn input.pop\r\n```",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/7379/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/7379/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}