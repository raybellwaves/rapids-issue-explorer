{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/11990",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/11990/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/11990/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/11990/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/11990",
    "id": 1422808895,
    "node_id": "I_kwDOBWUGps5Uzlc_",
    "number": 11990,
    "title": "[ENH/QST] actually inplace updates in `__setitem__` and friends",
    "user": {
        "login": "wence-",
        "id": 1126981,
        "node_id": "MDQ6VXNlcjExMjY5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/wence-",
        "html_url": "https://github.com/wence-",
        "followers_url": "https://api.github.com/users/wence-/followers",
        "following_url": "https://api.github.com/users/wence-/following{/other_user}",
        "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
        "organizations_url": "https://api.github.com/users/wence-/orgs",
        "repos_url": "https://api.github.com/users/wence-/repos",
        "events_url": "https://api.github.com/users/wence-/events{/privacy}",
        "received_events_url": "https://api.github.com/users/wence-/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1013987503,
            "node_id": "MDU6TGFiZWwxMDEzOTg3NTAz",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/2%20-%20In%20Progress",
            "name": "2 - In Progress",
            "color": "fef2c0",
            "default": false,
            "description": "Currently a work in progress"
        },
        {
            "id": 1139741213,
            "node_id": "MDU6TGFiZWwxMTM5NzQxMjEz",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Python",
            "name": "Python",
            "color": "1d76db",
            "default": false,
            "description": "Affects Python cuDF API."
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
        "login": "wence-",
        "id": 1126981,
        "node_id": "MDQ6VXNlcjExMjY5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/wence-",
        "html_url": "https://github.com/wence-",
        "followers_url": "https://api.github.com/users/wence-/followers",
        "following_url": "https://api.github.com/users/wence-/following{/other_user}",
        "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
        "organizations_url": "https://api.github.com/users/wence-/orgs",
        "repos_url": "https://api.github.com/users/wence-/repos",
        "events_url": "https://api.github.com/users/wence-/events{/privacy}",
        "received_events_url": "https://api.github.com/users/wence-/received_events",
        "type": "User",
        "site_admin": false
    },
    "assignees": [
        {
            "login": "wence-",
            "id": 1126981,
            "node_id": "MDQ6VXNlcjExMjY5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wence-",
            "html_url": "https://github.com/wence-",
            "followers_url": "https://api.github.com/users/wence-/followers",
            "following_url": "https://api.github.com/users/wence-/following{/other_user}",
            "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
            "organizations_url": "https://api.github.com/users/wence-/orgs",
            "repos_url": "https://api.github.com/users/wence-/repos",
            "events_url": "https://api.github.com/users/wence-/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wence-/received_events",
            "type": "User",
            "site_admin": false
        }
    ],
    "milestone": null,
    "comments": 7,
    "created_at": "2022-10-25T17:17:48Z",
    "updated_at": "2022-12-01T15:48:15Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "## Context\r\n\r\nAs noted in #11085, in many cases (though inconsistently right now), obtaining a view on `Series` (probably a `DataFrame` as well) using `iloc[:]` _inadvertently_ behaves with pseudo-copy-on-write semantics\r\n\r\n```python\r\nimport cudf\r\nimport numpy as np\r\ns = cudf.Series([1, 2, 3])\r\nsview = s.iloc[:]\r\ns.iloc[[1, 2]] = [4, 5]\r\nassert np.allclose(s.values, sview.values) # => False\r\n\r\nsview = s.iloc[:]\r\ns.iloc[0:2] = 3\r\nassert np.allclose(s.values, sview.values) # => True\r\n```\r\n\r\nNote: pandas is moving towards _all_ indexing [behaving with copy semantics](https://docs.google.com/document/d/1ZCQ9mx3LBMy-nhwRl33_jgcvWo9IWdEfxDNQ2thyTb0), so for some of these cases we've already skated to the right answer :)\r\n\r\n## Why does this happen?\r\n\r\nMost (but not all) of the `__setitem__`-like calls into (e.g. `copy_range`, `scatter`) `libcudf` do not operate in place, but instead return a new `cudf::column` that must be wrapped up. As a consequence, to pretend like the operation was in place, we call `_mimic_inplace(...)` to switch out the backing data of the `Column` object we're doing `__setitem__` on:\r\n\r\n```python\r\nimport cudf\r\ns = cudf.Series([1, 2, 3])\r\nold_data = s._column.data\r\ns.iloc[1:3] = [4, 5]\r\nnew_data = s._column.data\r\nassert old_data is new_data # => False\r\n```\r\n\r\nThis is kind of fine as long as there's only one object holding on to the column data, but this breaks down as soon as we have views.\r\n\r\n## Why is the status quo problematic?\r\n\r\n1. The current inconsistencies make implementing copy-on-write rather delicate (and in many cases provoke more copies than needed).\r\n2. Operations that to the user do not provoke a copy can overflow GPU memory:\r\n     ```python\r\n      # on a system with 32 GB gpu memory\r\n      import cudf\r\n      import cupy as cp\r\n      import numpy as np\r\n      df = cudf.DataFrame({f\"{i}\": cp.ones(10**9, dtype=np.uint8) for i in range(20)}) # about 20GB\r\n      # expectation: this behaves in place, so the operation should fit in memory.\r\n      df.iloc[[0, 2]] = list(range(20)) # => MemoryError: std::bad_alloc: out_of_memory: CUDA error at: rmm/mr/device/cuda_memory_resource.hpp\r\n    ````\r\n3. If the scatter/copy_foo operations in libcudf had an in place then we would have lower memory pressure (as point 2) and in the (common) case where we have a target table view, could avoid a memcopy of the whole table.\r\n\r\n## Possible solutions\r\n\r\nI don't know the history as to why the libcudf generally tends to offer \"return a copy\" rather than \"modify in place\", but one could make an effort to offer in place versions of most functions. If these operations were available, then the Cython layer could switch to calling into them. In those cases where we really want a copy, we would allocate and copy into an empty table before calling into libcudf.\r\n\r\nEdit: modification in place only works at the libcudf level for fixed-width column types (so no strings, lists), and having in- and out-of-place modification for every operation is too much work without some significant motivating use case.\r\n\r\nSince we need a work-around that works for string/list columns that cannot by modified in-place _anyway_, I don't think this issue is a sufficiently motivating use case.\r\n\r\nThe above solution is a no-go, so what else could we do?\r\n\r\n- Given that we're trying to move to copy-on-write, we could go the other way and audit all places where `__setitem__` really is in place, and break that connection. ~Note that this is not actually copy-on-write, but copy-on-read so it's not a great option.~ Something close to this probably is copy-on-write, so looks perhaps reasonable.\r\n- ~Change the way `_mimic_inplace(self, other, inplace=True)` works: rather than rewriting where `self.data` points to, we could instead `memcopy` from `other.data` back into `self.data` and then drop `other`. This maintains the same memory footprint right now, at the cost of (another) full `memcopy`, and makes `__setitem__` really behave in place (even for views).~ As pointed out below, this doesn't work for non-fixed-width column dtypes.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/11990/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/11990/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}