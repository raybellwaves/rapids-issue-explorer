{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/12495",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/12495/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/12495/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/12495/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/12495",
    "id": 1523401080,
    "node_id": "I_kwDOBWUGps5azUF4",
    "number": 12495,
    "title": "[FEA] Improve dtype dispatch patterns in Python",
    "user": {
        "login": "vyasr",
        "id": 1538165,
        "node_id": "MDQ6VXNlcjE1MzgxNjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1538165?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vyasr",
        "html_url": "https://github.com/vyasr",
        "followers_url": "https://api.github.com/users/vyasr/followers",
        "following_url": "https://api.github.com/users/vyasr/following{/other_user}",
        "gists_url": "https://api.github.com/users/vyasr/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/vyasr/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/vyasr/subscriptions",
        "organizations_url": "https://api.github.com/users/vyasr/orgs",
        "repos_url": "https://api.github.com/users/vyasr/repos",
        "events_url": "https://api.github.com/users/vyasr/events{/privacy}",
        "received_events_url": "https://api.github.com/users/vyasr/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1139741213,
            "node_id": "MDU6TGFiZWwxMTM5NzQxMjEz",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Python",
            "name": "Python",
            "color": "1d76db",
            "default": false,
            "description": "Affects Python cuDF API."
        },
        {
            "id": 1322252617,
            "node_id": "MDU6TGFiZWwxMzIyMjUyNjE3",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Performance",
            "name": "Performance",
            "color": "C2E0C6",
            "default": false,
            "description": "Performance related issue"
        },
        {
            "id": 2546521024,
            "node_id": "MDU6TGFiZWwyNTQ2NTIxMDI0",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/improvement",
            "name": "improvement",
            "color": "bfd4f2",
            "default": false,
            "description": "Improvement / enhancement to an existing function"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-01-07T02:01:22Z",
    "updated_at": "2023-01-07T02:02:41Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nThere are numerous places in cudf that require polymorphic behavior depending on the dtype of a parameter. Two of the most prominent are `ColumnBase.astype` and `build_column`, both of which essentially boil down to a switch statement based on the dtype. \r\n\r\nThere are numerous issues with this implementation. Two of the most obvious ones are:\r\n- Performance: See #12494 \r\n- It violates the open-closed principle. There is no way to register new types. For `ColumnBase.astype`, this is managed by having the various `as_*_dtype` methods defined in `ColumnBase`, but there is no way to add a new one in general. The only real option would be to monkey-patch the method (same for `build_column`).\r\n- It violates the single responsibility principle. The logic for a new data type's column leaks into the parent ColumnBase's module as well as into helper functions.\r\n\r\n**Describe the solution you'd like**\r\nThe ideal solution here would be something like `functools.singledispatch` where we register a new override for each dtype and input types are cached to avoid needing to do the expensive `is_*_dtype` calls each time. Unfortunately, this approach is not directly viable because the caching of `singledispatch` is based on the class of the input value, and dtypes cannot be differentiated in this way. For instance, any dtype may be specified as a string.\r\n\r\nWe should implement a TypeDispatcher (name modeled after libcudf's) that can handle the required type-based single dispatch. The dispatcher could cache the determination of the dtype and run the appropriate method. Unlike `singledispatch`, the dispatch would cache values rather than types. Here is a quick example of what this could look:\r\n```\r\nfrom functools import lru_cache\r\n\r\n\r\nclass TypeDispatcher:\r\n    def __init__(self, func):\r\n        self._default_func = func\r\n        self._funcs = []\r\n        self._preds = []\r\n\r\n    def register(self, predicate):\r\n        # Not trying to be thread-safe here.\r\n        self._preds.append(predicate)\r\n\r\n        def register_typ(func):\r\n            self._funcs.append(func)\r\n            return func\r\n        return register_typ\r\n\r\n    @lru_cache\r\n    def _get_func(self, obj):\r\n        for pred, func in zip(self._preds, self._funcs):\r\n            if pred(obj):\r\n                return func\r\n        return self._default_func\r\n\r\n    # May want to do some functools.wraps magic to match the signature.\r\n    def __call__(self, x, *args, **kwargs):\r\n        return self._get_func(x)(x, *args, **kwargs)\r\n\r\n\r\n@TypeDispatcher\r\ndef f(x):\r\n    raise ValueError(\"Unsupported type\")\r\n\r\n\r\n@f.register(lambda x: isinstance(x, int))\r\ndef _(x):\r\n    return x * 2\r\n\r\n\r\n@f.register(lambda x: isinstance(x, str))\r\ndef _(x):\r\n    return x * 3\r\n```\r\n\r\nThe crucial benefit of this approach (even beyond the performance benefits of the cache) is the ability of external code to register new overloads. Creating a new type of column would no longer require modification of the base column, making our hierarchy much more extensible and removing one major roadblock to supporting alternate column types. Additionally, from an organizational standpoint, it makes the code much easier to follow when all the code relevant to a new column is in one place. \r\n\r\n**Describe alternatives you've considered**\r\nDepending on how many different places implement this sort of dispatch, it could be beneficial to decouple the predicates from the functions so that the predicates can be reused, since by assumption they will be identical across all relevant functions. In other words, all instances of `TypeDispatcher` could share a global registry mapping cached objects to their types, but each instance could store a separate mapping from types to functions. That would allow a centralized registration of predicates and even more cache benefits. However, it would require a couple of extra things that may not be worthwhile:\r\n1. Standardizing the way in which the types are keyed so that registration could be done identically everywhere e.g. `@f.register(\"int_like\")`\r\n2. Implementing separate APIs for registering new types and predicates to the class vs registering a new overload for a specific `TypeDispatcher` instance.\r\n\r\n**Additional context**\r\nFor primitive predicates like the one in my example above, I would expect that the overhead of `lru_cache` and dictionary lookups would be slower than the naive if-else cascade. My assumption is that for the more complex `is_*_dtype` predicates used for dtype-dispatched functions this is not the case.\r\n\r\nIt's also worth noting that this value-based approach has pitfalls in general around what is considered equal, but those should not bite us when used for dtypes. For instance, `isinstance(1, int)` is True but so is `isinstance(1, float)`. That shouldn't cause us any particular issues though since we are working with dtypes and there are no such overlaps.\r\n\r\nThis approach may need some modification to work with class methods instead of free functions.\r\n\r\nThe [multimethod package](https://multimethod.readthedocs.io/en/latest/readme.html#overload) supports this sort of predicate-based overloading (in addition to type-based dispatch), but I think our needs are narrow enough that we are better off at least prototyping this ourselves before reaching to add another dependency.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/12495/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/12495/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}