{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/13526",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/13526/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/13526/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/13526/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/13526",
    "id": 1746304851,
    "node_id": "I_kwDOBWUGps5oFn9T",
    "number": 13526,
    "title": "[FEA] Use table_view interface in scatter-by-foo API in CUDF",
    "user": {
        "login": "wence-",
        "id": 1126981,
        "node_id": "MDQ6VXNlcjExMjY5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/wence-",
        "html_url": "https://github.com/wence-",
        "followers_url": "https://api.github.com/users/wence-/followers",
        "following_url": "https://api.github.com/users/wence-/following{/other_user}",
        "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
        "organizations_url": "https://api.github.com/users/wence-/orgs",
        "repos_url": "https://api.github.com/users/wence-/repos",
        "events_url": "https://api.github.com/users/wence-/events{/privacy}",
        "received_events_url": "https://api.github.com/users/wence-/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1139741213,
            "node_id": "MDU6TGFiZWwxMTM5NzQxMjEz",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Python",
            "name": "Python",
            "color": "1d76db",
            "default": false,
            "description": "Affects Python cuDF API."
        },
        {
            "id": 1322252617,
            "node_id": "MDU6TGFiZWwxMzIyMjUyNjE3",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Performance",
            "name": "Performance",
            "color": "C2E0C6",
            "default": false,
            "description": "Performance related issue"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-06-07T16:46:17Z",
    "updated_at": "2023-06-13T10:29:02Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "Both the scatter-like and gather-like Cython interfaces to libcudf's copying API accept a list of source and target columns as a \"table\". This feature is, however, only _used_ in the front-facing API by the gather-like calls.\r\n\r\nFor scatter-like calls on a dataframe, the final result is usually achieved by creating series for each column to scatter to/from and calling the singleton scatter on the series before reconstructing. This is more wasteful than it needs to be and we should probably instead just create the list of columns we wish to scatter and scatter that instead.\r\n\r\nFor example, the low-level Cython interface to scatter accepts a list of source and target columns:\r\n\r\nhttps://github.com/rapidsai/cudf/blob/8055c2db6f80286b64d36f3927510bcf2e0eec02/python/cudf/cudf/_lib/copying.pyx#L240\r\n\r\nHowever, the only caller in the python codebase is `ColumnBase._scatter_by_column` https://github.com/rapidsai/cudf/blob/8055c2db6f80286b64d36f3927510bcf2e0eec02/python/cudf/cudf/core/column/column.py#L647-L682 where we only have a single column to hand and hence can only pass one column.\r\n\r\nThis is usage is a consequence of `__setitem__` on `DataFrame`s ultimately being implemented by spinning over the columns (as series) and calling setitem on each series in turn. For example, `DataFrameIlocIndexer.__setitem__` has this code (when setting columns using a dataframe as the rvalue):\r\n\r\nhttps://github.com/rapidsai/cudf/blob/8055c2db6f80286b64d36f3927510bcf2e0eec02/python/cudf/cudf/core/dataframe.py#L466-L477\r\n\r\nThis calls (on line 474) `Series.__setitem__` on each which either goes to `series.iloc.__setitem__` or `series.loc.__setitem__`, and eventually devolves to `ColumnBase.__setitem__`.\r\n\r\n(Aside, this is actually a bug, since `iloc.__setitem__` should not do index alignment which `loc` will do).\r\n\r\nIgnoring that bug issue, this code is somewhat wasteful in a number of ways:\r\n\r\n1. we eventually throw away the `Series` object when reconstructing the dataframe, so should just operate on columns\r\n2. at this point in `DataFrame.iloc.__setitem__` we _already know_ everything about the key (and hence which low-level libcudf operation to dispatch to) so we should do that rather than going through the front door of `Series.__setitem__` which will endeavour to rediscover everything we already know.\r\n3. we call into libcudf n times (once for each column), rather than once with n columns, which negates the ability to use the stream parallelism that is implemented in the `scatter` code in libcudf\r\n\r\nTo fix this, I propose that `DataFrame` and `Series` should both get a new set of methods. Here's a first pass at what these should be called/their interface. These are internal and should do no argument normalisation or bounds-checking (it being the responsibility of the caller to sanitise appropriately), this includes kind/dtype casting as appropriate of the source and target.\r\n\r\n- `_scatter_by_indices(self, source_columns, index_column, *, keep_index=True)`\r\n- `_scatter_by_mask(self, source_columns, mask_column, *, keep_index=True)`\r\n- `_scatter_by_slice(self, source_columns, slice, *, keep_index=True)`\r\n\r\nSince there is also a broadcasting `scatter_from_scalar` operation in libcudf we'll probably need to support that too. This should be done with a `value_type` tag in the interface (rather than isinstancing on the `source_columns`) since, again, the caller must have already determined this information.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/13526/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/13526/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}