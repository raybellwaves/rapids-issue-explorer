{
    "url": "https://api.github.com/repos/rapidsai/cudf/issues/15620",
    "repository_url": "https://api.github.com/repos/rapidsai/cudf",
    "labels_url": "https://api.github.com/repos/rapidsai/cudf/issues/15620/labels{/name}",
    "comments_url": "https://api.github.com/repos/rapidsai/cudf/issues/15620/comments",
    "events_url": "https://api.github.com/repos/rapidsai/cudf/issues/15620/events",
    "html_url": "https://github.com/rapidsai/cudf/issues/15620",
    "id": 2272133041,
    "node_id": "I_kwDOBWUGps6Hbf-x",
    "number": 15620,
    "title": "[FEA] Use SMs to submit small copies to prevent serialization on a busy copy engine",
    "user": {
        "login": "abellina",
        "id": 1901059,
        "node_id": "MDQ6VXNlcjE5MDEwNTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1901059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/abellina",
        "html_url": "https://github.com/abellina",
        "followers_url": "https://api.github.com/users/abellina/followers",
        "following_url": "https://api.github.com/users/abellina/following{/other_user}",
        "gists_url": "https://api.github.com/users/abellina/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/abellina/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/abellina/subscriptions",
        "organizations_url": "https://api.github.com/users/abellina/orgs",
        "repos_url": "https://api.github.com/users/abellina/repos",
        "events_url": "https://api.github.com/users/abellina/events{/privacy}",
        "received_events_url": "https://api.github.com/users/abellina/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 599626561,
            "node_id": "MDU6TGFiZWw1OTk2MjY1NjE=",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 1405146975,
            "node_id": "MDU6TGFiZWwxNDA1MTQ2OTc1",
            "url": "https://api.github.com/repos/rapidsai/cudf/labels/Spark",
            "name": "Spark",
            "color": "7400ff",
            "default": false,
            "description": "Functionality that helps Spark RAPIDS"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2024-04-30T17:45:40Z",
    "updated_at": "2024-05-03T18:40:51Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "We have seen patterns where small `cudaMemcpyAsync` collide with large `cudaMemcpyAsync` being handled by the copy engine. Importantly, the small copy is in a different stream than the large copy.  In the example below, we can see a H2D pinned copy of 51KB that was scheduled with a latency of _12ms_ because there is another pinned H2D copy happening at the same time (the larger copy is ~200MB).\r\n\r\n![2024-04-30_10-35](https://github.com/rapidsai/cudf/assets/1901059/58e6a601-8ffb-490b-931f-1e7deee82dcd)\r\n\r\nThe big issue behind this pattern is that Stream 30 in this case is serializing because nothing else will run in the stream until this small copy is done. Usually when we invoke kernels in cuDF there is a pattern of: small H2Ds, followed by kernel invocation, then small D2Hs. Any of the pre/post copies done around a kernel is a candidate to get stuck, serializing all the work in that stream.\r\n\r\nWe have a PoC that uses `thrust::copy_n` to copy from pinned to device memory and viceversa using SMs instead of the copy engine, as kernels can directly touch pinned memory. When such an approach is followed, the small copy is able to run with much less latency and subsequent work in the stream is unblocked. This leads to kernels running at the same time as large copies, which is a desirable pattern. \r\n\r\nThis issue was created in order to track this work and to figure out how to bring these changes to cuDF in a configurable way so we don't affect serial workloads, as the effect is really prominent for parallel workloads such as Spark.\r\n\r\nThis is NDS q9 at 3TB, looking at the CUDA HW row, we can see how the compute (blue) overlaps more often than not with pinned H2Ds (green).\r\n\r\nBefore:\r\n![2024-04-30_10-43](https://github.com/rapidsai/cudf/assets/1901059/783b32bb-9750-4bdb-a164-daaea6ebab84)\r\n\r\nAfter:\r\n![2024-04-30_10-44](https://github.com/rapidsai/cudf/assets/1901059/54fce8ee-68db-4bb6-9985-782419e19337)\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/15620/reactions",
        "total_count": 1,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 1,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/rapidsai/cudf/issues/15620/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}