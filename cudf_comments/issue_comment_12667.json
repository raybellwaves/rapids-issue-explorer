[
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412646551",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1412646551",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1412646551,
        "node_id": "IC_kwDOBWUGps5UM0aX",
        "user": {
            "login": "davidwendt",
            "id": 45795991,
            "node_id": "MDQ6VXNlcjQ1Nzk1OTkx",
            "avatar_url": "https://avatars.githubusercontent.com/u/45795991?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/davidwendt",
            "html_url": "https://github.com/davidwendt",
            "followers_url": "https://api.github.com/users/davidwendt/followers",
            "following_url": "https://api.github.com/users/davidwendt/following{/other_user}",
            "gists_url": "https://api.github.com/users/davidwendt/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/davidwendt/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/davidwendt/subscriptions",
            "organizations_url": "https://api.github.com/users/davidwendt/orgs",
            "repos_url": "https://api.github.com/users/davidwendt/repos",
            "events_url": "https://api.github.com/users/davidwendt/events{/privacy}",
            "received_events_url": "https://api.github.com/users/davidwendt/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-01T20:01:10Z",
        "updated_at": "2023-02-01T20:01:10Z",
        "author_association": "CONTRIBUTOR",
        "body": "Investigating this I found the problem is reported through `thrust::exclusive_scan` which is implemented using CUB's `Device::ExclusiveScan`. Exclusive-scan is a unique function where the last element is not processed. For example,\r\n\r\n```\r\nint data[6] = {1, 0, 2, 2, 1, 3};\r\nthrust::exclusive_scan(data, data + 6, data); // in-place scan\r\n// data is now {0, 1, 1, 3, 5, 6}\r\n\r\n```\r\nNote that the last element in `data` is not actually used. Any value can be there and it would not affect the result.\r\n```\r\nint data[6] = {1, 0, 2, 2, 1, X};\r\nthrust::exclusive_scan(data, data + 6, data); // in-place scan\r\n// data is now {0, 1, 1, 3, 5, 6}\r\n```\r\n\r\nThe normal processing of strings APIs that return strings in libcudf is to do two passes. The 1st pass will compute the output sizes and is used to build the output chars column and offsets. The 2nd pass will fill in the chars column. The number of output offsets are usually known and so the output offsets column is created first. The 1st pass will place the sizes into this column temporarily. The sizes are usually only needed to build the offsets so there is normally no need to put the sizes into a separate temporary buffer/vector since the offsets can be computed directly in-place.\r\n\r\nAlthough the number of output sizes is the same as the number of output rows, the offsets count is always +1 the number of output rows. The first element is 0 and the final element is the the total size in bytes. The exclusive-scan does this for us in a single step:\r\n\r\n```\r\nint output_rows = 5;\r\nint offsets[] = {1, 2, 0, 2, 4, X};  // populated with sizes, the last entry is garbage\r\nthrust::exclusive_scan(offsets, offsets + 6, offsets);\r\n// offsets is now {0, 1, 3, 3, 5, 9}\r\n```\r\n\r\nAlthough the last element _may_ be read by thrust/CUB, it is never actually used. This is a limitation of the `initcheck` in `compute-sanitizer`. It only knows the uninitialized memory has been read, it has no idea that is not actually used in producing output. So I don't think we can reliably use `initcheck` to verify invalid usage of uninitialized data.\r\n\r\nI would not recommend fixing this by artificially setting the last entry since it would impact the performance unnecessarily in the many, many places that this is used.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412646551/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412666850",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1412666850",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1412666850,
        "node_id": "IC_kwDOBWUGps5UM5Xi",
        "user": {
            "login": "wence-",
            "id": 1126981,
            "node_id": "MDQ6VXNlcjExMjY5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wence-",
            "html_url": "https://github.com/wence-",
            "followers_url": "https://api.github.com/users/wence-/followers",
            "following_url": "https://api.github.com/users/wence-/following{/other_user}",
            "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
            "organizations_url": "https://api.github.com/users/wence-/orgs",
            "repos_url": "https://api.github.com/users/wence-/repos",
            "events_url": "https://api.github.com/users/wence-/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wence-/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-01T20:16:19Z",
        "updated_at": "2023-02-01T20:16:19Z",
        "author_association": "CONTRIBUTOR",
        "body": "Is this something we should take to the compute-sanitizer team?\r\n\r\nI would have thought that a write to the final entry would not provoke an uninitialised read warning (it wouldn't in host code with valgrind I think)",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412666850/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412688231",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1412688231",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1412688231,
        "node_id": "IC_kwDOBWUGps5UM-ln",
        "user": {
            "login": "davidwendt",
            "id": 45795991,
            "node_id": "MDQ6VXNlcjQ1Nzk1OTkx",
            "avatar_url": "https://avatars.githubusercontent.com/u/45795991?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/davidwendt",
            "html_url": "https://github.com/davidwendt",
            "followers_url": "https://api.github.com/users/davidwendt/followers",
            "following_url": "https://api.github.com/users/davidwendt/following{/other_user}",
            "gists_url": "https://api.github.com/users/davidwendt/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/davidwendt/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/davidwendt/subscriptions",
            "organizations_url": "https://api.github.com/users/davidwendt/orgs",
            "repos_url": "https://api.github.com/users/davidwendt/repos",
            "events_url": "https://api.github.com/users/davidwendt/events{/privacy}",
            "received_events_url": "https://api.github.com/users/davidwendt/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-01T20:35:16Z",
        "updated_at": "2023-02-01T20:35:16Z",
        "author_association": "CONTRIBUTOR",
        "body": "> Is this something we should take to the compute-sanitizer team?\r\n\r\nI doubt they can trace the read down to where it eventually is used/not-used -- at what level in the stack-trace does it actually get discarded. I'm guessing the values are block loaded into an array and then to a local register and then finally discarded. \r\n\r\n> I would have thought that a write to the final entry would not provoke an uninitialised read warning (it wouldn't in host code with valgrind I think)\r\n\r\nI believe thrust/CUB is doing a read of all available data in some low-level utility probably common to both types of scans or other CUB functions. The fact the last value eventually is not used is specific to exclusive-scan. It may be worth opening an issue with thrust but I fear the solution would be non-performant checks.\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412688231/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412713631",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1412713631",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1412713631,
        "node_id": "IC_kwDOBWUGps5UNEyf",
        "user": {
            "login": "vyasr",
            "id": 1538165,
            "node_id": "MDQ6VXNlcjE1MzgxNjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1538165?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vyasr",
            "html_url": "https://github.com/vyasr",
            "followers_url": "https://api.github.com/users/vyasr/followers",
            "following_url": "https://api.github.com/users/vyasr/following{/other_user}",
            "gists_url": "https://api.github.com/users/vyasr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vyasr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vyasr/subscriptions",
            "organizations_url": "https://api.github.com/users/vyasr/orgs",
            "repos_url": "https://api.github.com/users/vyasr/repos",
            "events_url": "https://api.github.com/users/vyasr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vyasr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-01T21:00:39Z",
        "updated_at": "2023-02-01T21:00:39Z",
        "author_association": "CONTRIBUTOR",
        "body": "In an ideal world (not saying this is in any way possible right now) this seems like a case where compute sanitizer would offer something like pragmas to allow code to say \"this block is going to include unsafe accesses, ignore them because it's actually OK\". I don't know that there's any other general fix, since IIUC effectively what is happening is that thrust is performing an unsafe access to potentially garbage data but it's OK because the value that is read will never be used.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1412713631/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1413566150",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1413566150",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1413566150,
        "node_id": "IC_kwDOBWUGps5UQU7G",
        "user": {
            "login": "wence-",
            "id": 1126981,
            "node_id": "MDQ6VXNlcjExMjY5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wence-",
            "html_url": "https://github.com/wence-",
            "followers_url": "https://api.github.com/users/wence-/followers",
            "following_url": "https://api.github.com/users/wence-/following{/other_user}",
            "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
            "organizations_url": "https://api.github.com/users/wence-/orgs",
            "repos_url": "https://api.github.com/users/wence-/repos",
            "events_url": "https://api.github.com/users/wence-/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wence-/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-02T11:09:57Z",
        "updated_at": "2023-02-02T11:09:57Z",
        "author_association": "CONTRIBUTOR",
        "body": "> I believe thrust/CUB is doing a read of all available data in some low-level utility probably common to both types of scans or other CUB functions. The fact the last value eventually is not used is specific to exclusive-scan. It may be worth opening an issue with thrust but I fear the solution would be non-performant checks.\r\n\r\nFWIW, I think the cudf usage here is UB (if we're going by thrust modelling std::algorithm). Since the first two arguments to `thrust::exclusive_scan` must model `InputIterator` which says that the full range of the iterator must be dereferencable. Since it is UB to read an uninitialised value, dereferencing the last entry in the input iterator is bad (since it _is_ uninitialised).\r\n\r\nArguably an `exclusive_scan` implementation doesn't need to dereference the last entry of the input iterator, but I can't see anything in the standard that requires that of an implementation.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1413566150/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1413850107",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1413850107",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1413850107,
        "node_id": "IC_kwDOBWUGps5URaP7",
        "user": {
            "login": "wence-",
            "id": 1126981,
            "node_id": "MDQ6VXNlcjExMjY5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wence-",
            "html_url": "https://github.com/wence-",
            "followers_url": "https://api.github.com/users/wence-/followers",
            "following_url": "https://api.github.com/users/wence-/following{/other_user}",
            "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
            "organizations_url": "https://api.github.com/users/wence-/orgs",
            "repos_url": "https://api.github.com/users/wence-/repos",
            "events_url": "https://api.github.com/users/wence-/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wence-/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-02T14:41:02Z",
        "updated_at": "2023-02-02T14:41:02Z",
        "author_association": "CONTRIBUTOR",
        "body": "Related request to guarantee that the final entry of the input iterator is never read by CUB https://github.com/NVIDIA/cccl/issues/876\r\n\r\nIn terms of general uninitialized memory. Perhaps there should be a compile time option (off by default) for libcudf to zero-initialize device allocations (this is probably much harder than it sounds), to be used as a debugging tool.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1413850107/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1423357895",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1423357895",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1423357895,
        "node_id": "IC_kwDOBWUGps5U1rfH",
        "user": {
            "login": "vyasr",
            "id": 1538165,
            "node_id": "MDQ6VXNlcjE1MzgxNjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1538165?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vyasr",
            "html_url": "https://github.com/vyasr",
            "followers_url": "https://api.github.com/users/vyasr/followers",
            "following_url": "https://api.github.com/users/vyasr/following{/other_user}",
            "gists_url": "https://api.github.com/users/vyasr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vyasr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vyasr/subscriptions",
            "organizations_url": "https://api.github.com/users/vyasr/orgs",
            "repos_url": "https://api.github.com/users/vyasr/repos",
            "events_url": "https://api.github.com/users/vyasr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vyasr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-08T23:09:12Z",
        "updated_at": "2023-02-08T23:09:12Z",
        "author_association": "CONTRIBUTOR",
        "body": "I agree, it seems like another case of technically UB but we're taking advantage of knowing the implementation detail that in practice this is safe. I doubt that that std::exclusive_scan standard will be modified to account for the desire to not read the final value, but I suppose thrust could promise that anyway. If there's a cub request then a thrust request also seems appropriate, @jrhemstad WDYT?",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1423357895/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1423921552",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1423921552",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1423921552,
        "node_id": "IC_kwDOBWUGps5U31GQ",
        "user": {
            "login": "wence-",
            "id": 1126981,
            "node_id": "MDQ6VXNlcjExMjY5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1126981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wence-",
            "html_url": "https://github.com/wence-",
            "followers_url": "https://api.github.com/users/wence-/followers",
            "following_url": "https://api.github.com/users/wence-/following{/other_user}",
            "gists_url": "https://api.github.com/users/wence-/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wence-/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wence-/subscriptions",
            "organizations_url": "https://api.github.com/users/wence-/orgs",
            "repos_url": "https://api.github.com/users/wence-/repos",
            "events_url": "https://api.github.com/users/wence-/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wence-/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-09T09:59:39Z",
        "updated_at": "2023-02-09T09:59:39Z",
        "author_association": "CONTRIBUTOR",
        "body": "> technically UB but we're taking advantage of knowing the implementation detail that in practice this is safe.\r\n\r\nAlthough this works right now, this is not how UB works. A sufficiently smart compiler\u2122 will treat UB as an impossible situation, and is free to (for example) eliminate any code related to it. In this circumstance, that might be elimination of the call to `exclusive_scan` completely (admittedly the reasoning to get here is pretty convoluted, so I don't think it is very likely that this would occur, since the iteration bounds to the iterator that partially initialise the input to `exclusive_scan` are not compile-time known). So it would be a totally valid to erase any calls to `sizes_to_offsets` that occur in these contexts. Even if the implementation of `exclusive_scan` remains unchanged.\r\n\r\nI agree with @davidwendt that running an extra kernel to memset the final entry in the allocated offsets array to zero is not the solution.\r\n\r\nI would prefer to try and fix this in CUB, and ideally the C++ standard, though I don't know how amenable they'd be to changing the definition of exclusive_scan.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1423921552/reactions",
            "total_count": 1,
            "+1": 0,
            "-1": 0,
            "laugh": 1,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1426289078",
        "html_url": "https://github.com/rapidsai/cudf/issues/12667#issuecomment-1426289078",
        "issue_url": "https://api.github.com/repos/rapidsai/cudf/issues/12667",
        "id": 1426289078,
        "node_id": "IC_kwDOBWUGps5VA3G2",
        "user": {
            "login": "vyasr",
            "id": 1538165,
            "node_id": "MDQ6VXNlcjE1MzgxNjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1538165?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vyasr",
            "html_url": "https://github.com/vyasr",
            "followers_url": "https://api.github.com/users/vyasr/followers",
            "following_url": "https://api.github.com/users/vyasr/following{/other_user}",
            "gists_url": "https://api.github.com/users/vyasr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vyasr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vyasr/subscriptions",
            "organizations_url": "https://api.github.com/users/vyasr/orgs",
            "repos_url": "https://api.github.com/users/vyasr/repos",
            "events_url": "https://api.github.com/users/vyasr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vyasr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-10T20:14:04Z",
        "updated_at": "2023-02-10T20:14:04Z",
        "author_association": "CONTRIBUTOR",
        "body": "I mean, that's the definition of an implementation detail right? UB says an implementation can do whatever it wants. One of the options is to do something that we think is sensible. We know empirically that the code thrust produces is not being elided in the way you describe by the CUDA compiler, even though it could be. I'm not saying that we should rely on the current behavior, of course. We need thrust to promise not to read the last value, which in turn means we need cub to promise not to read the last value. If we can get that upstreamed to the C++ standard for `std::exclusive_scan`, that's even better.",
        "reactions": {
            "url": "https://api.github.com/repos/rapidsai/cudf/issues/comments/1426289078/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]