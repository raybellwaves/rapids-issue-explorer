[
    {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1303761579",
        "html_url": "https://github.com/NVIDIA/spark-rapids/issues/7005#issuecomment-1303761579",
        "issue_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/7005",
        "id": 1303761579,
        "node_id": "IC_kwDOD7z77c5NtdKr",
        "user": {
            "login": "revans2",
            "id": 3441321,
            "node_id": "MDQ6VXNlcjM0NDEzMjE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/revans2",
            "html_url": "https://github.com/revans2",
            "followers_url": "https://api.github.com/users/revans2/followers",
            "following_url": "https://api.github.com/users/revans2/following{/other_user}",
            "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
            "organizations_url": "https://api.github.com/users/revans2/orgs",
            "repos_url": "https://api.github.com/users/revans2/repos",
            "events_url": "https://api.github.com/users/revans2/events{/privacy}",
            "received_events_url": "https://api.github.com/users/revans2/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-11-04T15:25:58Z",
        "updated_at": "2022-11-04T15:25:58Z",
        "author_association": "COLLABORATOR",
        "body": "Those are the reasons that we don't replace `CollectLimitExec` by default. It is difficult to actually make this work given our current rules (but not impossible).  From a performance standpoint we might just want to insert a GpuLocalLimitExec ahead of the CollectLimitExec. We are going to have to pull back N rows to the CPU anyways for the  `executeCollect` to work. In the common case only a single task is going to run with a `CollectLimitExec` and a reasonable number of rows, so why not just limit those rows before we copy it to the CPU?",
        "reactions": {
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1303761579/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1306509576",
        "html_url": "https://github.com/NVIDIA/spark-rapids/issues/7005#issuecomment-1306509576",
        "issue_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/7005",
        "id": 1306509576,
        "node_id": "IC_kwDOD7z77c5N38EI",
        "user": {
            "login": "firestarman",
            "id": 7280411,
            "node_id": "MDQ6VXNlcjcyODA0MTE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7280411?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/firestarman",
            "html_url": "https://github.com/firestarman",
            "followers_url": "https://api.github.com/users/firestarman/followers",
            "following_url": "https://api.github.com/users/firestarman/following{/other_user}",
            "gists_url": "https://api.github.com/users/firestarman/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/firestarman/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/firestarman/subscriptions",
            "organizations_url": "https://api.github.com/users/firestarman/orgs",
            "repos_url": "https://api.github.com/users/firestarman/repos",
            "events_url": "https://api.github.com/users/firestarman/events{/privacy}",
            "received_events_url": "https://api.github.com/users/firestarman/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-11-08T02:03:21Z",
        "updated_at": "2022-11-09T07:18:38Z",
        "author_association": "COLLABORATOR",
        "body": "> In the common case only a single task is going to run with a CollectLimitExec and a reasonable number of rows, so why not just limit those rows before we copy it to the CPU?\r\n\r\nHi, not fully get what you mean for the last suggestion.\r\n\r\nIf `CollectLimitExec ` is always  or commonly used as the last operation, how about marking it not support columnar processing, and implement the `execute` and `executeCollect`, where it calls the child's `executeColumnar` and fetch only the limit rows, similar to what `GpuColumnarToRowExec` does.\r\n\r\nBesides, add a rule to make sure a `ColumnarToRowExec ` will not be inserted before the `CollectLimitExec `. Then cases like show, take, head will run into `executeCollect ` path, where it avoids the shuffle in `execute`.\r\n\r\nOf course there should be many details I miss here, but this is an overall idea.\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1306509576/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1307513698",
        "html_url": "https://github.com/NVIDIA/spark-rapids/issues/7005#issuecomment-1307513698",
        "issue_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/7005",
        "id": 1307513698,
        "node_id": "IC_kwDOD7z77c5N7xNi",
        "user": {
            "login": "revans2",
            "id": 3441321,
            "node_id": "MDQ6VXNlcjM0NDEzMjE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/revans2",
            "html_url": "https://github.com/revans2",
            "followers_url": "https://api.github.com/users/revans2/followers",
            "following_url": "https://api.github.com/users/revans2/following{/other_user}",
            "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
            "organizations_url": "https://api.github.com/users/revans2/orgs",
            "repos_url": "https://api.github.com/users/revans2/repos",
            "events_url": "https://api.github.com/users/revans2/events{/privacy}",
            "received_events_url": "https://api.github.com/users/revans2/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-11-08T16:45:20Z",
        "updated_at": "2022-11-08T16:45:20Z",
        "author_association": "COLLABORATOR",
        "body": "> If `CollectLimitExec ` is always or commonly used as the last operation, how about mark it not support columnar processing, and implement the `execute` and `executeCollect`, where it calls the child's `executeColumnar` and fetch only the limit rows, similar to what `GpuColumnarToRowExec` does.\r\n\r\nThat is essentially what I am suggesting, but hopefully with less code changes.\r\n\r\nWhat we have today.\r\n\r\n```\r\nColumnarProcessing ... -> ColumnarToRow -> CollectLimitExec\r\n```\r\n\r\nThis works, but `ColumnarToRow` is going to move at least one full batch of data from the GPU to the CPU so that `CollectLimitExec` can throw away everything but the first N rows.\r\n\r\nYou are proposing to fix this by having a `GpuCollectLimitExec` that would do three steps.\r\n1. Limit the input data using the GPU\r\n2. Copy the columnar data to the CPU and convert it into rows\r\n3. Return the row based data using the `executeCollect` API\r\n\r\n```\r\nColumnarProcessing ... -> |            GpuCollectLimitExec            |\r\n                          | Limit -> ColumnarToRow -> executeCollect  |\r\n```\r\n\r\nThis is fine and works, but it means that we have to mark `GpuCollectLimitExec` as doing the columnar to row transition so the planning rules handle it properly and don't try to insert in extra transitions.\r\n\r\nWhat I am proposing is to use existing Execs to do the same thing.\r\n\r\n```\r\nColumnarProcessing ... -> GpuLocalLimitExec -> GpuColumnarToRowExec -> CollectLimitExec\r\n```\r\n\r\n@firestarman your solution would end up being cleaner on the UI, which is a big advantage for end users. So if you are willing to put in the effort to make that happen I would love to see it. I was just thinking of how we could do it with as little work as possible.",
        "reactions": {
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/1307513698/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]