[
    {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/2149002948",
        "html_url": "https://github.com/NVIDIA/spark-rapids/issues/10980#issuecomment-2149002948",
        "issue_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/10980",
        "id": 2149002948,
        "node_id": "IC_kwDOD7z77c6AFy7E",
        "user": {
            "login": "thirtiseven",
            "id": 7326403,
            "node_id": "MDQ6VXNlcjczMjY0MDM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7326403?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/thirtiseven",
            "html_url": "https://github.com/thirtiseven",
            "followers_url": "https://api.github.com/users/thirtiseven/followers",
            "following_url": "https://api.github.com/users/thirtiseven/following{/other_user}",
            "gists_url": "https://api.github.com/users/thirtiseven/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/thirtiseven/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/thirtiseven/subscriptions",
            "organizations_url": "https://api.github.com/users/thirtiseven/orgs",
            "repos_url": "https://api.github.com/users/thirtiseven/repos",
            "events_url": "https://api.github.com/users/thirtiseven/events{/privacy}",
            "received_events_url": "https://api.github.com/users/thirtiseven/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-06-05T06:43:49Z",
        "updated_at": "2024-06-05T06:43:49Z",
        "author_association": "COLLABORATOR",
        "body": "Specific cases in Spark UT that fails (commented):\r\n```scala\r\n test(\"SPARK-35112: Cast string to day-time interval2\") {\r\n//    checkEvaluation(cast(Literal.create(\"0\"), DayTimeIntervalType()), 0L)\r\n//    checkEvaluation(cast(Literal.create(\"0 0:0:0\"), DayTimeIntervalType()), 0L)\r\n//    checkEvaluation(cast(Literal.create(\" interval '0 0:0:0' Day TO second   \"),\r\n//      DayTimeIntervalType()), 0L)\r\n    checkEvaluation(cast(Literal.create(\"INTERVAL '1 2:03:04' DAY TO SECOND\"),\r\n      DayTimeIntervalType()), 93784000000L)\r\n    checkEvaluation(cast(Literal.create(\"INTERVAL '1 03:04:00' DAY TO SECOND\"),\r\n      DayTimeIntervalType()), 97440000000L)\r\n    checkEvaluation(cast(Literal.create(\"INTERVAL '1 03:04:00.0000' DAY TO SECOND\"),\r\n      DayTimeIntervalType()), 97440000000L)\r\n//    checkEvaluation(cast(Literal.create(\"1 2:03:04\"), DayTimeIntervalType()), 93784000000L)\r\n    checkEvaluation(cast(Literal.create(\"INTERVAL '-10 2:03:04' DAY TO SECOND\"),\r\n      DayTimeIntervalType()), -871384000000L)\r\n//    checkEvaluation(cast(Literal.create(\"-10 2:03:04\"), DayTimeIntervalType()), -871384000000L)\r\n//    checkEvaluation(cast(Literal.create(\"-106751991 04:00:54.775808\"), DayTimeIntervalType()),\r\n//      Long.MinValue)\r\n//    checkEvaluation(cast(Literal.create(\"106751991 04:00:54.775807\"), DayTimeIntervalType()),\r\n//      Long.MaxValue)\r\n//\r\n//    Seq(\"-106751991 04:00:54.775808\", \"106751991 04:00:54.775807\").foreach { interval =>\r\n//      val ansiInterval = s\"INTERVAL '$interval' DAY TO SECOND\"\r\n//      checkEvaluation(\r\n//        cast(cast(Literal.create(interval), DayTimeIntervalType()), StringType), ansiInterval)\r\n//      checkEvaluation(cast(cast(Literal.create(ansiInterval),\r\n//        DayTimeIntervalType()), StringType), ansiInterval)\r\n//    }\r\n//\r\n    if (!isTryCast) {\r\n      Seq(\"INTERVAL '-106751991 04:00:54.775809' DAY TO SECOND\",\r\n        \"INTERVAL '106751991 04:00:54.775808' DAY TO SECOND\").foreach { interval =>\r\n        val e = intercept[ArithmeticException] {\r\n          cast(Literal.create(interval), DayTimeIntervalType()).eval()\r\n        }.getMessage\r\n        assert(e.contains(\"long overflow\"))\r\n      }\r\n    }\r\n\r\n    Seq(Byte.MaxValue, Short.MaxValue, Int.MaxValue, Long.MaxValue, Long.MinValue + 1,\r\n      Long.MinValue).foreach { duration =>\r\n      val interval = Literal.create(\r\n        Duration.of(duration, ChronoUnit.MICROS),\r\n        DayTimeIntervalType())\r\n      checkEvaluation(cast(cast(interval, StringType), DayTimeIntervalType()), duration)\r\n    }\r\n  }\r\n\r\n  test(\"SPARK-35735: Take into account day-time interval fields in cast2\") {\r\n    def typeName(dataType: DayTimeIntervalType): String = {\r\n      if (dataType.startField == dataType.endField) {\r\n        DayTimeIntervalType.fieldToString(dataType.startField).toUpperCase(Locale.ROOT)\r\n      } else {\r\n        s\"${DayTimeIntervalType.fieldToString(dataType.startField)} TO \" +\r\n          s\"${DayTimeIntervalType.fieldToString(dataType.endField)}\".toUpperCase(Locale.ROOT)\r\n      }\r\n    }\r\n\r\n    Seq((\"1\", DayTimeIntervalType(DAY, DAY), (86400) * MICROS_PER_SECOND),\r\n      (\"-1\", DayTimeIntervalType(DAY, DAY), -(86400) * MICROS_PER_SECOND),\r\n      (\"1 01\", DayTimeIntervalType(DAY, HOUR), (86400 + 3600) * MICROS_PER_SECOND),\r\n      (\"-1 01\", DayTimeIntervalType(DAY, HOUR), -(86400 + 3600) * MICROS_PER_SECOND),\r\n      (\"1 01:01\", DayTimeIntervalType(DAY, MINUTE), (86400 + 3600 + 60) * MICROS_PER_SECOND),\r\n      (\"-1 01:01\", DayTimeIntervalType(DAY, MINUTE), -(86400 + 3600 + 60) * MICROS_PER_SECOND),\r\n      (\"1 01:01:01.12345\", DayTimeIntervalType(DAY, SECOND),\r\n        ((86400 + 3600 + 60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n      (\"-1 01:01:01.12345\", DayTimeIntervalType(DAY, SECOND),\r\n        (-(86400 + 3600 + 60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n\r\n      (\"01\", DayTimeIntervalType(HOUR, HOUR), (3600) * MICROS_PER_SECOND),\r\n      (\"-01\", DayTimeIntervalType(HOUR, HOUR), -(3600) * MICROS_PER_SECOND),\r\n      (\"01:01\", DayTimeIntervalType(HOUR, MINUTE), (3600 + 60) * MICROS_PER_SECOND),\r\n      (\"-01:01\", DayTimeIntervalType(HOUR, MINUTE), -(3600 + 60) * MICROS_PER_SECOND),\r\n      (\"01:01:01.12345\", DayTimeIntervalType(HOUR, SECOND),\r\n        ((3600 + 60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n      (\"-01:01:01.12345\", DayTimeIntervalType(HOUR, SECOND),\r\n        (-(3600 + 60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n\r\n      (\"01\", DayTimeIntervalType(MINUTE, MINUTE), (60) * MICROS_PER_SECOND),\r\n      (\"-01\", DayTimeIntervalType(MINUTE, MINUTE), -(60) * MICROS_PER_SECOND),\r\n      (\"01:01\", DayTimeIntervalType(MINUTE, SECOND), ((60 + 1) * MICROS_PER_SECOND)),\r\n      (\"01:01.12345\", DayTimeIntervalType(MINUTE, SECOND),\r\n        ((60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n      (\"-01:01.12345\", DayTimeIntervalType(MINUTE, SECOND),\r\n        (-(60 + 1.12345) * MICROS_PER_SECOND).toLong),\r\n\r\n      (\"01.12345\", DayTimeIntervalType(SECOND, SECOND), ((1.12345) * MICROS_PER_SECOND).toLong),\r\n      (\"-01.12345\", DayTimeIntervalType(SECOND, SECOND), (-(1.12345) * MICROS_PER_SECOND).toLong))\r\n      .foreach { case (str, dataType, dt) =>\r\n//        checkEvaluation(cast(Literal.create(str), dataType), dt)\r\n        checkEvaluation(\r\n          cast(Literal.create(s\"INTERVAL '$str' ${typeName(dataType)}\"), dataType), dt)\r\n        checkEvaluation(\r\n          cast(Literal.create(s\"INTERVAL -'$str' ${typeName(dataType)}\"), dataType), -dt)\r\n      }\r\n\r\n    // Check max value\r\n    Seq((\"INTERVAL '106751991' DAY\", DayTimeIntervalType(DAY), 106751991L * MICROS_PER_DAY),\r\n      (\"INTERVAL '106751991 04' DAY TO HOUR\", DayTimeIntervalType(DAY, HOUR), 9223372036800000000L),\r\n      (\"INTERVAL '106751991 04:00' DAY TO MINUTE\",\r\n        DayTimeIntervalType(DAY, MINUTE), 9223372036800000000L),\r\n      (\"INTERVAL '106751991 04:00:54.775807' DAY TO SECOND\", DayTimeIntervalType(), Long.MaxValue),\r\n      (\"INTERVAL '2562047788' HOUR\", DayTimeIntervalType(HOUR), 9223372036800000000L),\r\n      (\"INTERVAL '2562047788:00' HOUR TO MINUTE\",\r\n        DayTimeIntervalType(HOUR, MINUTE), 9223372036800000000L),\r\n      (\"INTERVAL '2562047788:00:54.775807' HOUR TO SECOND\",\r\n        DayTimeIntervalType(HOUR, SECOND), Long.MaxValue),\r\n      (\"INTERVAL '153722867280' MINUTE\", DayTimeIntervalType(MINUTE), 9223372036800000000L),\r\n      (\"INTERVAL '153722867280:54.775807' MINUTE TO SECOND\",\r\n        DayTimeIntervalType(MINUTE, SECOND), Long.MaxValue),\r\n      (\"INTERVAL '9223372036854.775807' SECOND\", DayTimeIntervalType(SECOND), Long.MaxValue))\r\n      .foreach { case (interval, dataType, dt) =>\r\n        checkEvaluation(cast(Literal.create(interval), dataType), dt)\r\n        checkEvaluation(cast(Literal.create(interval.toLowerCase(Locale.ROOT)), dataType), dt)\r\n      }\r\n\r\n    Seq((\"INTERVAL '-106751991' DAY\", DayTimeIntervalType(DAY), -106751991L * MICROS_PER_DAY),\r\n      (\"INTERVAL '-106751991 04' DAY TO HOUR\",\r\n        DayTimeIntervalType(DAY, HOUR), -9223372036800000000L),\r\n      (\"INTERVAL '-106751991 04:00' DAY TO MINUTE\",\r\n        DayTimeIntervalType(DAY, MINUTE), -9223372036800000000L),\r\n      (\"INTERVAL '-106751991 04:00:54.775808' DAY TO SECOND\", DayTimeIntervalType(), Long.MinValue),\r\n      (\"INTERVAL '-2562047788' HOUR\", DayTimeIntervalType(HOUR), -9223372036800000000L),\r\n      (\"INTERVAL '-2562047788:00' HOUR TO MINUTE\",\r\n        DayTimeIntervalType(HOUR, MINUTE), -9223372036800000000L),\r\n      (\"INTERVAL '-2562047788:00:54.775808' HOUR TO SECOND\",\r\n        DayTimeIntervalType(HOUR, SECOND), Long.MinValue),\r\n      (\"INTERVAL '-153722867280' MINUTE\", DayTimeIntervalType(MINUTE), -9223372036800000000L),\r\n      (\"INTERVAL '-153722867280:54.775808' MINUTE TO SECOND\",\r\n        DayTimeIntervalType(MINUTE, SECOND), Long.MinValue),\r\n      (\"INTERVAL '-9223372036854.775808' SECOND\", DayTimeIntervalType(SECOND), Long.MinValue))\r\n      .foreach { case (interval, dataType, dt) =>\r\n        checkEvaluation(cast(Literal.create(interval), dataType), dt)\r\n      }\r\n\r\n    if (!isTryCast) {\r\n      Seq(\r\n        (\"INTERVAL '1 01:01:01.12345' DAY TO SECOND\", DayTimeIntervalType(DAY, HOUR)),\r\n        (\"INTERVAL '1 01:01:01.12345' DAY TO HOUR\", DayTimeIntervalType(DAY, SECOND)),\r\n        (\"INTERVAL '1 01:01:01.12345' DAY TO MINUTE\", DayTimeIntervalType(DAY, MINUTE)),\r\n        (\"1 01:01:01.12345\", DayTimeIntervalType(DAY, DAY)),\r\n        (\"1 01:01:01.12345\", DayTimeIntervalType(DAY, HOUR)),\r\n        (\"1 01:01:01.12345\", DayTimeIntervalType(DAY, MINUTE)),\r\n\r\n        (\"INTERVAL '01:01:01.12345' HOUR TO SECOND\", DayTimeIntervalType(DAY, HOUR)),\r\n        (\"INTERVAL '01:01:01.12345' HOUR TO HOUR\", DayTimeIntervalType(DAY, SECOND)),\r\n        (\"INTERVAL '01:01:01.12345' HOUR TO MINUTE\", DayTimeIntervalType(DAY, MINUTE)),\r\n        (\"01:01:01.12345\", DayTimeIntervalType(DAY, DAY)),\r\n        (\"01:01:01.12345\", DayTimeIntervalType(HOUR, HOUR)),\r\n        (\"01:01:01.12345\", DayTimeIntervalType(DAY, MINUTE)),\r\n        (\"INTERVAL '1.23' DAY\", DayTimeIntervalType(DAY)),\r\n        (\"INTERVAL '1.23' HOUR\", DayTimeIntervalType(HOUR)),\r\n        (\"INTERVAL '1.23' MINUTE\", DayTimeIntervalType(MINUTE)),\r\n        (\"INTERVAL '1.23' SECOND\", DayTimeIntervalType(MINUTE)),\r\n        (\"1.23\", DayTimeIntervalType(DAY)),\r\n        (\"1.23\", DayTimeIntervalType(HOUR)),\r\n        (\"1.23\", DayTimeIntervalType(MINUTE)),\r\n        (\"1.23\", DayTimeIntervalType(MINUTE)))\r\n        .foreach { case (interval, dataType) =>\r\n          val e = intercept[IllegalArgumentException] {\r\n            cast(Literal.create(interval), dataType).eval()\r\n          }.getMessage\r\n          assert(e.contains(s\"Interval string does not match day-time format of \" +\r\n            s\"${IntervalUtils.supportedFormat((dataType.startField, dataType.endField))\r\n              .map(format => s\"`$format`\").mkString(\", \")} \" +\r\n            s\"when cast to ${dataType.typeName}: $interval, \" +\r\n            s\"set ${SQLConf.LEGACY_FROM_DAYTIME_STRING.key} to true \" +\r\n            \"to restore the behavior before Spark 3.0.\"))\r\n        }\r\n\r\n      // Check first field outof bound\r\n      Seq((\"INTERVAL '1067519911' DAY\", DayTimeIntervalType(DAY)),\r\n        (\"INTERVAL '10675199111 04' DAY TO HOUR\", DayTimeIntervalType(DAY, HOUR)),\r\n        (\"INTERVAL '1067519911 04:00' DAY TO MINUTE\", DayTimeIntervalType(DAY, MINUTE)),\r\n        (\"INTERVAL '1067519911 04:00:54.775807' DAY TO SECOND\", DayTimeIntervalType()),\r\n        (\"INTERVAL '25620477881' HOUR\", DayTimeIntervalType(HOUR)),\r\n        (\"INTERVAL '25620477881:00' HOUR TO MINUTE\", DayTimeIntervalType(HOUR, MINUTE)),\r\n        (\"INTERVAL '25620477881:00:54.775807' HOUR TO SECOND\", DayTimeIntervalType(HOUR, SECOND)),\r\n        (\"INTERVAL '1537228672801' MINUTE\", DayTimeIntervalType(MINUTE)),\r\n        (\"INTERVAL '1537228672801:54.7757' MINUTE TO SECOND\", DayTimeIntervalType(MINUTE, SECOND)),\r\n        (\"INTERVAL '92233720368541.775807' SECOND\", DayTimeIntervalType(SECOND)))\r\n        .foreach { case (interval, dataType) =>\r\n          val e = intercept[IllegalArgumentException] {\r\n            cast(Literal.create(interval), dataType).eval()\r\n          }.getMessage\r\n          assert(e.contains(s\"Interval string does not match day-time format of \" +\r\n            s\"${IntervalUtils.supportedFormat((dataType.startField, dataType.endField))\r\n              .map(format => s\"`$format`\").mkString(\", \")} \" +\r\n            s\"when cast to ${dataType.typeName}: $interval, \" +\r\n            s\"set ${SQLConf.LEGACY_FROM_DAYTIME_STRING.key} to true \" +\r\n            \"to restore the behavior before Spark 3.0.\"))\r\n        }\r\n    }\r\n  }\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/comments/2149002948/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]