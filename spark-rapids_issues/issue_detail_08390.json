{
    "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390",
    "repository_url": "https://api.github.com/repos/NVIDIA/spark-rapids",
    "labels_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390/labels{/name}",
    "comments_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390/comments",
    "events_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390/events",
    "html_url": "https://github.com/NVIDIA/spark-rapids/issues/8390",
    "id": 1724737144,
    "node_id": "I_kwDOD7z77c5mzWZ4",
    "number": 8390,
    "title": "[FEA] See if an intermediate merge helps reduce memory in hash aggregate",
    "user": {
        "login": "revans2",
        "id": 3441321,
        "node_id": "MDQ6VXNlcjM0NDEzMjE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/revans2",
        "html_url": "https://github.com/revans2",
        "followers_url": "https://api.github.com/users/revans2/followers",
        "following_url": "https://api.github.com/users/revans2/following{/other_user}",
        "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
        "organizations_url": "https://api.github.com/users/revans2/orgs",
        "repos_url": "https://api.github.com/users/revans2/repos",
        "events_url": "https://api.github.com/users/revans2/events{/privacy}",
        "received_events_url": "https://api.github.com/users/revans2/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 2061735884,
            "node_id": "MDU6TGFiZWwyMDYxNzM1ODg0",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 2094500742,
            "node_id": "MDU6TGFiZWwyMDk0NTAwNzQy",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/performance",
            "name": "performance",
            "color": "d845b1",
            "default": false,
            "description": "A performance related task/issue"
        },
        {
            "id": 4029093938,
            "node_id": "LA_kwDOD7z77c7wJxgy",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/reliability",
            "name": "reliability",
            "color": "2654AF",
            "default": false,
            "description": "Features to improve reliability or bugs that severly impact the reliability of the plugin"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-05-24T21:04:58Z",
    "updated_at": "2023-05-31T18:14:15Z",
    "closed_at": null,
    "author_association": "COLLABORATOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nCurrently when doing a hash aggregate we will do an initial aggregate per batch and save away the resulting batch. When we are done we look at the size of those intermediate batches and if it is too large we do a sort + key partitioning pass on the intermediate data and then can do the final pass per batch that comes out.\r\n\r\nThis generally works, but we might end up using a lot more intermediate data to store those merge results than we should, which might cause us to sort more often than we need to.  This would happen when we have a lot of input data, multiple batches, which reduces the size decently, but the keys are evenly distributed through all the batches. It is rather common to have something  like a GpuExpandExec or a join that explodes right before an aggregation that drops the size of the data down to something really small again.\r\n\r\nIt would be great to test out what happens if we put in a heuristic where we have a merging of intermediate batches.  \r\n\r\nWhen a batch is added we would see if there is more than one pending batch and if the sum of those batches is larger than 1/2 the target batch size.  It should probably not take into account batches that have already been merged once when making the decision to merge batches. If the check passes then we would concat all of those batches together, including ones that have already been merged previously, unless the size would be too large..., and do a merge aggregation on them which would replace the existing input batches with the new merged result. If the size of the output data did not go down by at least some percentage (I am thinking 50%, but we should play with this) then we set a flag and stop trying to merge the intermediate results.  This would be to protect us against situations where it looks like we are not going to combine anything at all.\r\n\r\nThis is related https://github.com/NVIDIA/spark-rapids/issues/7404 where if ti really looks like nothing is going to combine on a partial aggregate, it might be worth just passing the batches on through to the shuffle.  But we might want to have the heuristic for that be a little higher than 50%. Would need to play with both of those to see what really works well. To be clear #7404 should be separate from this. I just think if we do this and the numbers look good, it might be nice to see what happens if we add #7404 to it because it should be fairly simple to do.\r\n\r\nAs for testing I want to see a number of different situations that we test from both a performance and a reliability standpoint.  All of these would be from the standpoint of a lot of data going into a small number of tasks. Like we had way too few shuffle partitions for the size of the data.  A lot of this is going to really be about the cardinality and ordering of the grouping keys.\r\n\r\nI want to see what happens when the key's\r\n    1. cardinality is high and is highly grouped (the data is almost sorted by the key, should get good combining initially, but not after a first pass) \r\n    2. cardinality is high and is randomly distributed (should get almost no combining in the partial)\r\n    3. cardinality is low and is highly grouped\r\n    4. cardinality is low and is randomly distributed\r\n    5. cardinality is medium and is high grouped\r\n    6. cardinality is medium and is randomly distributed\r\n\r\nBy high cardinality I mean we each key shows up 2 to 3 times in the entire dataset, for medium 200 to 300 times, and for low 20,000 to 30,000 times.  But we want enough data that a single task cannot hold all of it in GPU memory. At least a few hundred GiB of data.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/8390/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}