{
    "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955",
    "repository_url": "https://api.github.com/repos/NVIDIA/spark-rapids",
    "labels_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955/labels{/name}",
    "comments_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955/comments",
    "events_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955/events",
    "html_url": "https://github.com/NVIDIA/spark-rapids/issues/6955",
    "id": 1430272277,
    "node_id": "I_kwDOD7z77c5VQDkV",
    "number": 6955,
    "title": "[FEA] Explore CPU execution of specific expressions",
    "user": {
        "login": "revans2",
        "id": 3441321,
        "node_id": "MDQ6VXNlcjM0NDEzMjE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3441321?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/revans2",
        "html_url": "https://github.com/revans2",
        "followers_url": "https://api.github.com/users/revans2/followers",
        "following_url": "https://api.github.com/users/revans2/following{/other_user}",
        "gists_url": "https://api.github.com/users/revans2/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/revans2/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/revans2/subscriptions",
        "organizations_url": "https://api.github.com/users/revans2/orgs",
        "repos_url": "https://api.github.com/users/revans2/repos",
        "events_url": "https://api.github.com/users/revans2/events{/privacy}",
        "received_events_url": "https://api.github.com/users/revans2/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 2061735884,
            "node_id": "MDU6TGFiZWwyMDYxNzM1ODg0",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/feature%20request",
            "name": "feature request",
            "color": "a2eeef",
            "default": false,
            "description": "New feature or request"
        },
        {
            "id": 2094500742,
            "node_id": "MDU6TGFiZWwyMDk0NTAwNzQy",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/performance",
            "name": "performance",
            "color": "d845b1",
            "default": false,
            "description": "A performance related task/issue"
        },
        {
            "id": 2589743725,
            "node_id": "MDU6TGFiZWwyNTg5NzQzNzI1",
            "url": "https://api.github.com/repos/NVIDIA/spark-rapids/labels/epic",
            "name": "epic",
            "color": "0E8A16",
            "default": false,
            "description": "Issue that encompasses a significant feature or body of work"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-10-31T18:11:46Z",
    "updated_at": "2022-11-01T22:07:27Z",
    "closed_at": null,
    "author_association": "COLLABORATOR",
    "active_lock_reason": null,
    "body": "**Is your feature request related to a problem? Please describe.**\r\nThere are some expressions where a GPU implementation is going to be very expensive to implement or possibly impossible to do in the general case. Our current solution is to fall back to the CPU at the operator level. We fall back for an entire Project if there is a single expression in the Project that we cannot do on the GPU.  This works for producing the correct answer, but may not be the best performing solution. We should explore what a partial fallback solution might look like.\r\n\r\n- We currently have `spark.rapids.sql.rowBasedUDF.enabled` that lets us put a UDF on the CPU, but do so with the GPU semaphore held. We should look at what the performance impact is for something like this but for a more concrete operator, like `regexp_extract`. We know that there are a lot of regular expression cases that we cannot currently support so regular expressions is a good starting point for this.\r\n- If the results from the first experiment look good we should look at trying to pull the expression out into a stand alone `ProjectExec` that can run CPU expressions intelligently. It would pull the input columns to the CPU, make the original input spillable, release the semaphore, run the CPU expressions and collect the results on the CPU, grab the semaphore, and copy the resulting columns back down to the GPU. We should do this for UDFs as well as the `regexp_extract` as a part of the experiments.\r\n- If that looks good we can look into how to pull out these types of CPU expressions more generally. How can we extract them from a `FilterExec` or a `HashAggregateExec` or any of the join operations.  These should probably be separate issues filed for each exec that we think could have these types of expressions in them.\r\n- We should then expand the types of expressions that we are looking at beyond regular expressions.  We might be able to make this work for any expression that we have never seen before.\r\n- We should also look at how we can configure this on/off. Do we want to have a generic config that enables/disables this feature entirely. Do we want to have a config per expression that we can set like we do to enable/disable individual expressions today?\r\n- Collect some performance numbers to see if it is worth enabling this by default. Especially in comparison to falling back to the CPU for an entire project or aggregation. We need to put on our malicious hats when doing this to try and thing of really bad situations to see the performance impact. Things like where we go back and forth between the CPU and the GPU a lot. We already don't do well with this and this issue is not to fix those cases. This is just us verifying that we are not making those situations much worse.\r\n- The final step would be to look into cost based optimizations.\r\n\r\nThe cost based optimizations I was thinking about would probably look mostly at the cost of data movement, but we need to do some experiments to see if there are other things that would be good to add in too, like a SWAG at the cost of doing an operation on the GPU vs the CPU.\r\n\r\nFor example lets say we have an expression like `regexp_extract(FOO, 'SOMETHING THAT DOES NOT WORK ON GPU') = 'BAR'` We know that the `regexp_extract` we cannot do on the GPU, and the result of copying it back to the GPU afterwards would at least be copying the offsets back (an int per row but could be a lot larger).  But we know that copying a boolean back is going to be much cheaper than copying a string so we probably should put the equality check on the CPU too, even though we could do it on the GPU.\r\n\r\n\nhttps://github.com/NVIDIA/spark-rapids/issues/6955#tasklist-block-beb5e4f8-d7ad-4e1e-a353-8f31cedf72df\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/NVIDIA/spark-rapids/issues/6955/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}